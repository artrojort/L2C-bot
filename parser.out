Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON
Rule 2     gotomain -> empty
Rule 3     main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY
Rule 4     main1 -> empty
Rule 5     setmain -> empty
Rule 6     funcsblock -> funcs funcsblock
Rule 7     funcsblock -> empty
Rule 8     funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
Rule 9     funcs1 -> empty
Rule 10    setscope -> ID
Rule 11    varsblock -> vars varsblock
Rule 12    varsblock -> empty
Rule 13    vars -> VARDEF type ID dimvar SEMICOLON
Rule 14    dimvar -> LBRACKET express RBRACKET
Rule 15    dimvar -> empty
Rule 16    paramsblock -> params paramsblock
Rule 17    paramsblock -> COMMA params paramsblock
Rule 18    paramsblock -> empty
Rule 19    params -> type ID
Rule 20    params -> empty
Rule 21    block -> statute SEMICOLON block
Rule 22    block -> empty
Rule 23    statute -> cond
Rule 24    statute -> assign
Rule 25    statute -> call
Rule 26    statute -> cin
Rule 27    statute -> cout
Rule 28    statute -> delay
Rule 29    statute -> forward
Rule 30    statute -> backward
Rule 31    statute -> turnleft
Rule 32    statute -> turnright
Rule 33    statute -> servo
Rule 34    statute -> lights
Rule 35    statute -> while
Rule 36    statute -> return
Rule 37    cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
Rule 38    gotoif -> empty
Rule 39    else -> ELSE LCURLY gotoelse block RCURLY else
Rule 40    else -> empty
Rule 41    gotoelse -> empty
Rule 42    assign -> ID punto array ASSIGN express
Rule 43    call -> era LPAREN insertfloor paramcall RPAREN endfloor
Rule 44    era -> ID
Rule 45    paramcall -> express paramcall1
Rule 46    paramcall -> empty
Rule 47    paramcall1 -> COMMA paramcall
Rule 48    paramcall1 -> empty
Rule 49    cin -> CIN LPAREN express RPAREN
Rule 50    cout -> COUT LPAREN express cout1 RPAREN
Rule 51    cout1 -> COMMA express cout1
Rule 52    cout1 -> empty
Rule 53    delay -> DELAY LPAREN express RPAREN
Rule 54    forward -> FORWARD LPAREN express RPAREN
Rule 55    backward -> BACKWARD LPAREN express RPAREN
Rule 56    turnleft -> TURNLEFT LPAREN express RPAREN
Rule 57    turnright -> TURNRIGHT LPAREN express RPAREN
Rule 58    servo -> SERVO LPAREN express RPAREN
Rule 59    lights -> LIGHTS LPAREN express COMMA express RPAREN
Rule 60    while -> WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
Rule 61    while1 -> empty
Rule 62    return -> RETURN LPAREN express RPAREN
Rule 63    len -> LEN LPAREN ID RPAREN
Rule 64    type -> INT
Rule 65    type -> FLOAT
Rule 66    type -> BOOL
Rule 67    type -> CHAR
Rule 68    type -> VOID
Rule 69    constant -> ID punto array
Rule 70    constant -> CTE_INT
Rule 71    constant -> CTE_FLOAT
Rule 72    constant -> CTE_CHAR
Rule 73    constant -> CTE_BOOL
Rule 74    array -> LBRACKET insertfloor express RBRACKET endfloor
Rule 75    array -> empty
Rule 76    punto -> empty
Rule 77    express -> relational express1
Rule 78    express1 -> andor express
Rule 79    express1 -> empty
Rule 80    andor -> AND
Rule 81    andor -> OR
Rule 82    relational -> exp relational1
Rule 83    relational -> NOT
Rule 84    relational1 -> compare exp
Rule 85    relational1 -> empty
Rule 86    compare -> LESSTHAN
Rule 87    compare -> GREATERTHAN
Rule 88    compare -> EQUALS
Rule 89    compare -> NOTEQUALS
Rule 90    exp -> term exp1
Rule 91    exp1 -> plusminus exp
Rule 92    exp1 -> empty
Rule 93    plusminus -> PLUS
Rule 94    plusminus -> MINUS
Rule 95    term -> factor term1
Rule 96    term1 -> multidivi term
Rule 97    term1 -> empty
Rule 98    multidivi -> MULTI
Rule 99    multidivi -> DIVI
Rule 100   factor -> LPAREN insertfloor express RPAREN endfloor
Rule 101   factor -> constant
Rule 102   factor -> call
Rule 103   factor -> len
Rule 104   insertfloor -> empty
Rule 105   endfloor -> empty
Rule 106   empty -> <empty>

Terminals, with rules where they appear

AND                  : 80
ASSIGN               : 42
BACKWARD             : 55
BOOL                 : 66
CHAR                 : 67
CIN                  : 49
COMMA                : 17 47 51 59
COUT                 : 50
CTE_BOOL             : 73
CTE_CHAR             : 72
CTE_FLOAT            : 71
CTE_INT              : 70
DELAY                : 53
DIVI                 : 99
ELSE                 : 39
EQUALS               : 88
FIN                  : 1
FLOAT                : 65
FORWARD              : 54
FUNCDEF              : 8
GREATERTHAN          : 87
ID                   : 10 13 19 42 44 63 69
IF                   : 37
INT                  : 64
LBRACKET             : 14 74
LCURLY               : 3 8 37 39 60
LEN                  : 63
LESSTHAN             : 86
LIGHTS               : 59
LPAREN               : 3 8 37 43 49 50 53 54 55 56 57 58 59 60 62 63 100
MAIN                 : 3
MINUS                : 94
MULTI                : 98
NOT                  : 83
NOTEQUALS            : 89
OR                   : 81
PLUS                 : 93
PROGRAM              : 1
RBRACKET             : 14 74
RCURLY               : 3 8 37 39 60
RETURN               : 62
RPAREN               : 3 8 37 43 49 50 53 54 55 56 57 58 59 60 62 63 100
SEMICOLON            : 1 13 21
SERVO                : 58
TURNLEFT             : 56
TURNRIGHT            : 57
VARDEF               : 13
VOID                 : 68
WHILE                : 60
error                : 

Nonterminals, with rules where they appear

andor                : 78
array                : 42 69
assign               : 24
backward             : 30
block                : 3 8 21 37 39 60
call                 : 25 102
cin                  : 26
compare              : 84
cond                 : 23
constant             : 101
cout                 : 27
cout1                : 50 51
delay                : 28
dimvar               : 13
else                 : 37 39
empty                : 2 4 5 7 9 12 15 18 20 22 38 40 41 46 48 52 61 75 76 79 85 92 97 104 105
endfloor             : 43 74 100
era                  : 43
exp                  : 82 84 91
exp1                 : 90
express              : 14 37 42 45 49 50 51 53 54 55 56 57 58 59 59 60 62 74 78 100
express1             : 77
factor               : 95
forward              : 29
funcs                : 6
funcs1               : 8
funcsblock           : 1 6
gotoelse             : 39
gotoif               : 37
gotomain             : 1
insertfloor          : 43 74 100
len                  : 103
lights               : 34
main                 : 1
main1                : 3
multidivi            : 96
paramcall            : 43 47
paramcall1           : 45
params               : 16 17
paramsblock          : 8 16 17
plusminus            : 91
program              : 0
punto                : 42 69
relational           : 77
relational1          : 82
return               : 36
servo                : 33
setmain              : 3
setscope             : 8
statute              : 21
term                 : 90 96
term1                : 95
turnleft             : 31
turnright            : 32
type                 : 8 13 19
vars                 : 11
varsblock            : 1 3 8 11
while                : 35
while1               : 60

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . gotomain varsblock funcsblock main FIN SEMICOLON
    (2) gotomain -> . empty
    (106) empty -> .

    VARDEF          reduce using rule 106 (empty -> .)
    FUNCDEF         reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)

    gotomain                       shift and go to state 3
    empty                          shift and go to state 4

state 3

    (1) program -> PROGRAM gotomain . varsblock funcsblock main FIN SEMICOLON
    (11) varsblock -> . vars varsblock
    (12) varsblock -> . empty
    (13) vars -> . VARDEF type ID dimvar SEMICOLON
    (106) empty -> .

    VARDEF          shift and go to state 8
    FUNCDEF         reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)

    varsblock                      shift and go to state 5
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 4

    (2) gotomain -> empty .

    VARDEF          reduce using rule 2 (gotomain -> empty .)
    FUNCDEF         reduce using rule 2 (gotomain -> empty .)
    MAIN            reduce using rule 2 (gotomain -> empty .)


state 5

    (1) program -> PROGRAM gotomain varsblock . funcsblock main FIN SEMICOLON
    (6) funcsblock -> . funcs funcsblock
    (7) funcsblock -> . empty
    (8) funcs -> . FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (106) empty -> .

    FUNCDEF         shift and go to state 12
    MAIN            reduce using rule 106 (empty -> .)

    funcsblock                     shift and go to state 9
    funcs                          shift and go to state 10
    empty                          shift and go to state 11

state 6

    (11) varsblock -> vars . varsblock
    (11) varsblock -> . vars varsblock
    (12) varsblock -> . empty
    (13) vars -> . VARDEF type ID dimvar SEMICOLON
    (106) empty -> .

    VARDEF          shift and go to state 8
    FUNCDEF         reduce using rule 106 (empty -> .)
    MAIN            reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CIN             reduce using rule 106 (empty -> .)
    COUT            reduce using rule 106 (empty -> .)
    DELAY           reduce using rule 106 (empty -> .)
    FORWARD         reduce using rule 106 (empty -> .)
    BACKWARD        reduce using rule 106 (empty -> .)
    TURNLEFT        reduce using rule 106 (empty -> .)
    TURNRIGHT       reduce using rule 106 (empty -> .)
    SERVO           reduce using rule 106 (empty -> .)
    LIGHTS          reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    RETURN          reduce using rule 106 (empty -> .)
    RCURLY          reduce using rule 106 (empty -> .)

    vars                           shift and go to state 6
    varsblock                      shift and go to state 13
    empty                          shift and go to state 7

state 7

    (12) varsblock -> empty .

    FUNCDEF         reduce using rule 12 (varsblock -> empty .)
    MAIN            reduce using rule 12 (varsblock -> empty .)
    IF              reduce using rule 12 (varsblock -> empty .)
    ID              reduce using rule 12 (varsblock -> empty .)
    CIN             reduce using rule 12 (varsblock -> empty .)
    COUT            reduce using rule 12 (varsblock -> empty .)
    DELAY           reduce using rule 12 (varsblock -> empty .)
    FORWARD         reduce using rule 12 (varsblock -> empty .)
    BACKWARD        reduce using rule 12 (varsblock -> empty .)
    TURNLEFT        reduce using rule 12 (varsblock -> empty .)
    TURNRIGHT       reduce using rule 12 (varsblock -> empty .)
    SERVO           reduce using rule 12 (varsblock -> empty .)
    LIGHTS          reduce using rule 12 (varsblock -> empty .)
    WHILE           reduce using rule 12 (varsblock -> empty .)
    RETURN          reduce using rule 12 (varsblock -> empty .)
    RCURLY          reduce using rule 12 (varsblock -> empty .)


state 8

    (13) vars -> VARDEF . type ID dimvar SEMICOLON
    (64) type -> . INT
    (65) type -> . FLOAT
    (66) type -> . BOOL
    (67) type -> . CHAR
    (68) type -> . VOID

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

    type                           shift and go to state 14

state 9

    (1) program -> PROGRAM gotomain varsblock funcsblock . main FIN SEMICOLON
    (3) main -> . MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY

    MAIN            shift and go to state 21

    main                           shift and go to state 20

state 10

    (6) funcsblock -> funcs . funcsblock
    (6) funcsblock -> . funcs funcsblock
    (7) funcsblock -> . empty
    (8) funcs -> . FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (106) empty -> .

    FUNCDEF         shift and go to state 12
    MAIN            reduce using rule 106 (empty -> .)

    funcs                          shift and go to state 10
    funcsblock                     shift and go to state 22
    empty                          shift and go to state 11

state 11

    (7) funcsblock -> empty .

    MAIN            reduce using rule 7 (funcsblock -> empty .)


state 12

    (8) funcs -> FUNCDEF . type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (64) type -> . INT
    (65) type -> . FLOAT
    (66) type -> . BOOL
    (67) type -> . CHAR
    (68) type -> . VOID

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

    type                           shift and go to state 23

state 13

    (11) varsblock -> vars varsblock .

    FUNCDEF         reduce using rule 11 (varsblock -> vars varsblock .)
    MAIN            reduce using rule 11 (varsblock -> vars varsblock .)
    IF              reduce using rule 11 (varsblock -> vars varsblock .)
    ID              reduce using rule 11 (varsblock -> vars varsblock .)
    CIN             reduce using rule 11 (varsblock -> vars varsblock .)
    COUT            reduce using rule 11 (varsblock -> vars varsblock .)
    DELAY           reduce using rule 11 (varsblock -> vars varsblock .)
    FORWARD         reduce using rule 11 (varsblock -> vars varsblock .)
    BACKWARD        reduce using rule 11 (varsblock -> vars varsblock .)
    TURNLEFT        reduce using rule 11 (varsblock -> vars varsblock .)
    TURNRIGHT       reduce using rule 11 (varsblock -> vars varsblock .)
    SERVO           reduce using rule 11 (varsblock -> vars varsblock .)
    LIGHTS          reduce using rule 11 (varsblock -> vars varsblock .)
    WHILE           reduce using rule 11 (varsblock -> vars varsblock .)
    RETURN          reduce using rule 11 (varsblock -> vars varsblock .)
    RCURLY          reduce using rule 11 (varsblock -> vars varsblock .)


state 14

    (13) vars -> VARDEF type . ID dimvar SEMICOLON

    ID              shift and go to state 24


state 15

    (64) type -> INT .

    ID              reduce using rule 64 (type -> INT .)


state 16

    (65) type -> FLOAT .

    ID              reduce using rule 65 (type -> FLOAT .)


state 17

    (66) type -> BOOL .

    ID              reduce using rule 66 (type -> BOOL .)


state 18

    (67) type -> CHAR .

    ID              reduce using rule 67 (type -> CHAR .)


state 19

    (68) type -> VOID .

    ID              reduce using rule 68 (type -> VOID .)


state 20

    (1) program -> PROGRAM gotomain varsblock funcsblock main . FIN SEMICOLON

    FIN             shift and go to state 25


state 21

    (3) main -> MAIN . setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY
    (5) setmain -> . empty
    (106) empty -> .

    LPAREN          reduce using rule 106 (empty -> .)

    setmain                        shift and go to state 26
    empty                          shift and go to state 27

state 22

    (6) funcsblock -> funcs funcsblock .

    MAIN            reduce using rule 6 (funcsblock -> funcs funcsblock .)


state 23

    (8) funcs -> FUNCDEF type . setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (10) setscope -> . ID

    ID              shift and go to state 29

    setscope                       shift and go to state 28

state 24

    (13) vars -> VARDEF type ID . dimvar SEMICOLON
    (14) dimvar -> . LBRACKET express RBRACKET
    (15) dimvar -> . empty
    (106) empty -> .

    LBRACKET        shift and go to state 31
    SEMICOLON       reduce using rule 106 (empty -> .)

    dimvar                         shift and go to state 30
    empty                          shift and go to state 32

state 25

    (1) program -> PROGRAM gotomain varsblock funcsblock main FIN . SEMICOLON

    SEMICOLON       shift and go to state 33


state 26

    (3) main -> MAIN setmain . LPAREN RPAREN LCURLY varsblock main1 block RCURLY

    LPAREN          shift and go to state 34


state 27

    (5) setmain -> empty .

    LPAREN          reduce using rule 5 (setmain -> empty .)


state 28

    (8) funcs -> FUNCDEF type setscope . LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY

    LPAREN          shift and go to state 35


state 29

    (10) setscope -> ID .

    LPAREN          reduce using rule 10 (setscope -> ID .)


state 30

    (13) vars -> VARDEF type ID dimvar . SEMICOLON

    SEMICOLON       shift and go to state 36


state 31

    (14) dimvar -> LBRACKET . express RBRACKET
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 37
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 32

    (15) dimvar -> empty .

    SEMICOLON       reduce using rule 15 (dimvar -> empty .)


state 33

    (1) program -> PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON .

    $end            reduce using rule 1 (program -> PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON .)


state 34

    (3) main -> MAIN setmain LPAREN . RPAREN LCURLY varsblock main1 block RCURLY

    RPAREN          shift and go to state 54


state 35

    (8) funcs -> FUNCDEF type setscope LPAREN . paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (16) paramsblock -> . params paramsblock
    (17) paramsblock -> . COMMA params paramsblock
    (18) paramsblock -> . empty
    (19) params -> . type ID
    (20) params -> . empty
    (106) empty -> .
    (64) type -> . INT
    (65) type -> . FLOAT
    (66) type -> . BOOL
    (67) type -> . CHAR
    (68) type -> . VOID

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMA           shift and go to state 58
    RPAREN          reduce using rule 106 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

  ! COMMA           [ reduce using rule 106 (empty -> .) ]
  ! INT             [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! BOOL            [ reduce using rule 106 (empty -> .) ]
  ! CHAR            [ reduce using rule 106 (empty -> .) ]
  ! VOID            [ reduce using rule 106 (empty -> .) ]

    type                           shift and go to state 55
    paramsblock                    shift and go to state 56
    params                         shift and go to state 57
    empty                          shift and go to state 59

state 36

    (13) vars -> VARDEF type ID dimvar SEMICOLON .

    VARDEF          reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    FUNCDEF         reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    MAIN            reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    IF              reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    ID              reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    CIN             reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    COUT            reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    DELAY           reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    FORWARD         reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    BACKWARD        reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    TURNLEFT        reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    TURNRIGHT       reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    SERVO           reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    LIGHTS          reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    WHILE           reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    RETURN          reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    RCURLY          reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)


state 37

    (14) dimvar -> LBRACKET express . RBRACKET

    RBRACKET        shift and go to state 60


state 38

    (77) express -> relational . express1
    (78) express1 -> . andor express
    (79) express1 -> . empty
    (80) andor -> . AND
    (81) andor -> . OR
    (106) empty -> .

    AND             shift and go to state 64
    OR              shift and go to state 65
    RBRACKET        reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    SEMICOLON       reduce using rule 106 (empty -> .)

    express1                       shift and go to state 61
    andor                          shift and go to state 62
    empty                          shift and go to state 63

state 39

    (82) relational -> exp . relational1
    (84) relational1 -> . compare exp
    (85) relational1 -> . empty
    (86) compare -> . LESSTHAN
    (87) compare -> . GREATERTHAN
    (88) compare -> . EQUALS
    (89) compare -> . NOTEQUALS
    (106) empty -> .

    LESSTHAN        shift and go to state 69
    GREATERTHAN     shift and go to state 70
    EQUALS          shift and go to state 71
    NOTEQUALS       shift and go to state 72
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    RBRACKET        reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    SEMICOLON       reduce using rule 106 (empty -> .)

    relational1                    shift and go to state 66
    compare                        shift and go to state 67
    empty                          shift and go to state 68

state 40

    (83) relational -> NOT .

    AND             reduce using rule 83 (relational -> NOT .)
    OR              reduce using rule 83 (relational -> NOT .)
    RBRACKET        reduce using rule 83 (relational -> NOT .)
    RPAREN          reduce using rule 83 (relational -> NOT .)
    COMMA           reduce using rule 83 (relational -> NOT .)
    SEMICOLON       reduce using rule 83 (relational -> NOT .)


state 41

    (90) exp -> term . exp1
    (91) exp1 -> . plusminus exp
    (92) exp1 -> . empty
    (93) plusminus -> . PLUS
    (94) plusminus -> . MINUS
    (106) empty -> .

    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    LESSTHAN        reduce using rule 106 (empty -> .)
    GREATERTHAN     reduce using rule 106 (empty -> .)
    EQUALS          reduce using rule 106 (empty -> .)
    NOTEQUALS       reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    RBRACKET        reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    SEMICOLON       reduce using rule 106 (empty -> .)

    exp1                           shift and go to state 73
    plusminus                      shift and go to state 74
    empty                          shift and go to state 75

state 42

    (95) term -> factor . term1
    (96) term1 -> . multidivi term
    (97) term1 -> . empty
    (98) multidivi -> . MULTI
    (99) multidivi -> . DIVI
    (106) empty -> .

    MULTI           shift and go to state 81
    DIVI            shift and go to state 82
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    LESSTHAN        reduce using rule 106 (empty -> .)
    GREATERTHAN     reduce using rule 106 (empty -> .)
    EQUALS          reduce using rule 106 (empty -> .)
    NOTEQUALS       reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    RBRACKET        reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    SEMICOLON       reduce using rule 106 (empty -> .)

    term1                          shift and go to state 78
    multidivi                      shift and go to state 79
    empty                          shift and go to state 80

state 43

    (100) factor -> LPAREN . insertfloor express RPAREN endfloor
    (104) insertfloor -> . empty
    (106) empty -> .

    NOT             reduce using rule 106 (empty -> .)
    LPAREN          reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CTE_INT         reduce using rule 106 (empty -> .)
    CTE_FLOAT       reduce using rule 106 (empty -> .)
    CTE_CHAR        reduce using rule 106 (empty -> .)
    CTE_BOOL        reduce using rule 106 (empty -> .)
    LEN             reduce using rule 106 (empty -> .)

    insertfloor                    shift and go to state 83
    empty                          shift and go to state 84

state 44

    (101) factor -> constant .

    MULTI           reduce using rule 101 (factor -> constant .)
    DIVI            reduce using rule 101 (factor -> constant .)
    PLUS            reduce using rule 101 (factor -> constant .)
    MINUS           reduce using rule 101 (factor -> constant .)
    LESSTHAN        reduce using rule 101 (factor -> constant .)
    GREATERTHAN     reduce using rule 101 (factor -> constant .)
    EQUALS          reduce using rule 101 (factor -> constant .)
    NOTEQUALS       reduce using rule 101 (factor -> constant .)
    AND             reduce using rule 101 (factor -> constant .)
    OR              reduce using rule 101 (factor -> constant .)
    RBRACKET        reduce using rule 101 (factor -> constant .)
    RPAREN          reduce using rule 101 (factor -> constant .)
    COMMA           reduce using rule 101 (factor -> constant .)
    SEMICOLON       reduce using rule 101 (factor -> constant .)


state 45

    (102) factor -> call .

    MULTI           reduce using rule 102 (factor -> call .)
    DIVI            reduce using rule 102 (factor -> call .)
    PLUS            reduce using rule 102 (factor -> call .)
    MINUS           reduce using rule 102 (factor -> call .)
    LESSTHAN        reduce using rule 102 (factor -> call .)
    GREATERTHAN     reduce using rule 102 (factor -> call .)
    EQUALS          reduce using rule 102 (factor -> call .)
    NOTEQUALS       reduce using rule 102 (factor -> call .)
    AND             reduce using rule 102 (factor -> call .)
    OR              reduce using rule 102 (factor -> call .)
    RBRACKET        reduce using rule 102 (factor -> call .)
    RPAREN          reduce using rule 102 (factor -> call .)
    COMMA           reduce using rule 102 (factor -> call .)
    SEMICOLON       reduce using rule 102 (factor -> call .)


state 46

    (103) factor -> len .

    MULTI           reduce using rule 103 (factor -> len .)
    DIVI            reduce using rule 103 (factor -> len .)
    PLUS            reduce using rule 103 (factor -> len .)
    MINUS           reduce using rule 103 (factor -> len .)
    LESSTHAN        reduce using rule 103 (factor -> len .)
    GREATERTHAN     reduce using rule 103 (factor -> len .)
    EQUALS          reduce using rule 103 (factor -> len .)
    NOTEQUALS       reduce using rule 103 (factor -> len .)
    AND             reduce using rule 103 (factor -> len .)
    OR              reduce using rule 103 (factor -> len .)
    RBRACKET        reduce using rule 103 (factor -> len .)
    RPAREN          reduce using rule 103 (factor -> len .)
    COMMA           reduce using rule 103 (factor -> len .)
    SEMICOLON       reduce using rule 103 (factor -> len .)


state 47

    (69) constant -> ID . punto array
    (44) era -> ID .
    (76) punto -> . empty
    (106) empty -> .

    LPAREN          reduce using rule 44 (era -> ID .)
    LBRACKET        reduce using rule 106 (empty -> .)
    MULTI           reduce using rule 106 (empty -> .)
    DIVI            reduce using rule 106 (empty -> .)
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    LESSTHAN        reduce using rule 106 (empty -> .)
    GREATERTHAN     reduce using rule 106 (empty -> .)
    EQUALS          reduce using rule 106 (empty -> .)
    NOTEQUALS       reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    RBRACKET        reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    SEMICOLON       reduce using rule 106 (empty -> .)

    punto                          shift and go to state 85
    empty                          shift and go to state 86

state 48

    (70) constant -> CTE_INT .

    MULTI           reduce using rule 70 (constant -> CTE_INT .)
    DIVI            reduce using rule 70 (constant -> CTE_INT .)
    PLUS            reduce using rule 70 (constant -> CTE_INT .)
    MINUS           reduce using rule 70 (constant -> CTE_INT .)
    LESSTHAN        reduce using rule 70 (constant -> CTE_INT .)
    GREATERTHAN     reduce using rule 70 (constant -> CTE_INT .)
    EQUALS          reduce using rule 70 (constant -> CTE_INT .)
    NOTEQUALS       reduce using rule 70 (constant -> CTE_INT .)
    AND             reduce using rule 70 (constant -> CTE_INT .)
    OR              reduce using rule 70 (constant -> CTE_INT .)
    RBRACKET        reduce using rule 70 (constant -> CTE_INT .)
    RPAREN          reduce using rule 70 (constant -> CTE_INT .)
    COMMA           reduce using rule 70 (constant -> CTE_INT .)
    SEMICOLON       reduce using rule 70 (constant -> CTE_INT .)


state 49

    (71) constant -> CTE_FLOAT .

    MULTI           reduce using rule 71 (constant -> CTE_FLOAT .)
    DIVI            reduce using rule 71 (constant -> CTE_FLOAT .)
    PLUS            reduce using rule 71 (constant -> CTE_FLOAT .)
    MINUS           reduce using rule 71 (constant -> CTE_FLOAT .)
    LESSTHAN        reduce using rule 71 (constant -> CTE_FLOAT .)
    GREATERTHAN     reduce using rule 71 (constant -> CTE_FLOAT .)
    EQUALS          reduce using rule 71 (constant -> CTE_FLOAT .)
    NOTEQUALS       reduce using rule 71 (constant -> CTE_FLOAT .)
    AND             reduce using rule 71 (constant -> CTE_FLOAT .)
    OR              reduce using rule 71 (constant -> CTE_FLOAT .)
    RBRACKET        reduce using rule 71 (constant -> CTE_FLOAT .)
    RPAREN          reduce using rule 71 (constant -> CTE_FLOAT .)
    COMMA           reduce using rule 71 (constant -> CTE_FLOAT .)
    SEMICOLON       reduce using rule 71 (constant -> CTE_FLOAT .)


state 50

    (72) constant -> CTE_CHAR .

    MULTI           reduce using rule 72 (constant -> CTE_CHAR .)
    DIVI            reduce using rule 72 (constant -> CTE_CHAR .)
    PLUS            reduce using rule 72 (constant -> CTE_CHAR .)
    MINUS           reduce using rule 72 (constant -> CTE_CHAR .)
    LESSTHAN        reduce using rule 72 (constant -> CTE_CHAR .)
    GREATERTHAN     reduce using rule 72 (constant -> CTE_CHAR .)
    EQUALS          reduce using rule 72 (constant -> CTE_CHAR .)
    NOTEQUALS       reduce using rule 72 (constant -> CTE_CHAR .)
    AND             reduce using rule 72 (constant -> CTE_CHAR .)
    OR              reduce using rule 72 (constant -> CTE_CHAR .)
    RBRACKET        reduce using rule 72 (constant -> CTE_CHAR .)
    RPAREN          reduce using rule 72 (constant -> CTE_CHAR .)
    COMMA           reduce using rule 72 (constant -> CTE_CHAR .)
    SEMICOLON       reduce using rule 72 (constant -> CTE_CHAR .)


state 51

    (73) constant -> CTE_BOOL .

    MULTI           reduce using rule 73 (constant -> CTE_BOOL .)
    DIVI            reduce using rule 73 (constant -> CTE_BOOL .)
    PLUS            reduce using rule 73 (constant -> CTE_BOOL .)
    MINUS           reduce using rule 73 (constant -> CTE_BOOL .)
    LESSTHAN        reduce using rule 73 (constant -> CTE_BOOL .)
    GREATERTHAN     reduce using rule 73 (constant -> CTE_BOOL .)
    EQUALS          reduce using rule 73 (constant -> CTE_BOOL .)
    NOTEQUALS       reduce using rule 73 (constant -> CTE_BOOL .)
    AND             reduce using rule 73 (constant -> CTE_BOOL .)
    OR              reduce using rule 73 (constant -> CTE_BOOL .)
    RBRACKET        reduce using rule 73 (constant -> CTE_BOOL .)
    RPAREN          reduce using rule 73 (constant -> CTE_BOOL .)
    COMMA           reduce using rule 73 (constant -> CTE_BOOL .)
    SEMICOLON       reduce using rule 73 (constant -> CTE_BOOL .)


state 52

    (43) call -> era . LPAREN insertfloor paramcall RPAREN endfloor

    LPAREN          shift and go to state 87


state 53

    (63) len -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 88


state 54

    (3) main -> MAIN setmain LPAREN RPAREN . LCURLY varsblock main1 block RCURLY

    LCURLY          shift and go to state 89


state 55

    (19) params -> type . ID

    ID              shift and go to state 90


state 56

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock . RPAREN LCURLY varsblock funcs1 block RCURLY

    RPAREN          shift and go to state 91


state 57

    (16) paramsblock -> params . paramsblock
    (16) paramsblock -> . params paramsblock
    (17) paramsblock -> . COMMA params paramsblock
    (18) paramsblock -> . empty
    (19) params -> . type ID
    (20) params -> . empty
    (106) empty -> .
    (64) type -> . INT
    (65) type -> . FLOAT
    (66) type -> . BOOL
    (67) type -> . CHAR
    (68) type -> . VOID

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMA           shift and go to state 58
    RPAREN          reduce using rule 106 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

  ! COMMA           [ reduce using rule 106 (empty -> .) ]
  ! INT             [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! BOOL            [ reduce using rule 106 (empty -> .) ]
  ! CHAR            [ reduce using rule 106 (empty -> .) ]
  ! VOID            [ reduce using rule 106 (empty -> .) ]

    params                         shift and go to state 57
    paramsblock                    shift and go to state 92
    empty                          shift and go to state 59
    type                           shift and go to state 55

state 58

    (17) paramsblock -> COMMA . params paramsblock
    (19) params -> . type ID
    (20) params -> . empty
    (64) type -> . INT
    (65) type -> . FLOAT
    (66) type -> . BOOL
    (67) type -> . CHAR
    (68) type -> . VOID
    (106) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19
    COMMA           reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)

  ! INT             [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! BOOL            [ reduce using rule 106 (empty -> .) ]
  ! CHAR            [ reduce using rule 106 (empty -> .) ]
  ! VOID            [ reduce using rule 106 (empty -> .) ]

    params                         shift and go to state 93
    type                           shift and go to state 55
    empty                          shift and go to state 94

state 59

    (18) paramsblock -> empty .
    (20) params -> empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 18 (paramsblock -> empty .)
    RPAREN          reduce using rule 18 (paramsblock -> empty .)
    COMMA           reduce using rule 20 (params -> empty .)
    INT             reduce using rule 20 (params -> empty .)
    FLOAT           reduce using rule 20 (params -> empty .)
    BOOL            reduce using rule 20 (params -> empty .)
    CHAR            reduce using rule 20 (params -> empty .)
    VOID            reduce using rule 20 (params -> empty .)

  ! RPAREN          [ reduce using rule 20 (params -> empty .) ]


state 60

    (14) dimvar -> LBRACKET express RBRACKET .

    SEMICOLON       reduce using rule 14 (dimvar -> LBRACKET express RBRACKET .)


state 61

    (77) express -> relational express1 .

    RBRACKET        reduce using rule 77 (express -> relational express1 .)
    RPAREN          reduce using rule 77 (express -> relational express1 .)
    COMMA           reduce using rule 77 (express -> relational express1 .)
    SEMICOLON       reduce using rule 77 (express -> relational express1 .)


state 62

    (78) express1 -> andor . express
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 95
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 63

    (79) express1 -> empty .

    RBRACKET        reduce using rule 79 (express1 -> empty .)
    RPAREN          reduce using rule 79 (express1 -> empty .)
    COMMA           reduce using rule 79 (express1 -> empty .)
    SEMICOLON       reduce using rule 79 (express1 -> empty .)


state 64

    (80) andor -> AND .

    NOT             reduce using rule 80 (andor -> AND .)
    LPAREN          reduce using rule 80 (andor -> AND .)
    ID              reduce using rule 80 (andor -> AND .)
    CTE_INT         reduce using rule 80 (andor -> AND .)
    CTE_FLOAT       reduce using rule 80 (andor -> AND .)
    CTE_CHAR        reduce using rule 80 (andor -> AND .)
    CTE_BOOL        reduce using rule 80 (andor -> AND .)
    LEN             reduce using rule 80 (andor -> AND .)


state 65

    (81) andor -> OR .

    NOT             reduce using rule 81 (andor -> OR .)
    LPAREN          reduce using rule 81 (andor -> OR .)
    ID              reduce using rule 81 (andor -> OR .)
    CTE_INT         reduce using rule 81 (andor -> OR .)
    CTE_FLOAT       reduce using rule 81 (andor -> OR .)
    CTE_CHAR        reduce using rule 81 (andor -> OR .)
    CTE_BOOL        reduce using rule 81 (andor -> OR .)
    LEN             reduce using rule 81 (andor -> OR .)


state 66

    (82) relational -> exp relational1 .

    AND             reduce using rule 82 (relational -> exp relational1 .)
    OR              reduce using rule 82 (relational -> exp relational1 .)
    RBRACKET        reduce using rule 82 (relational -> exp relational1 .)
    RPAREN          reduce using rule 82 (relational -> exp relational1 .)
    COMMA           reduce using rule 82 (relational -> exp relational1 .)
    SEMICOLON       reduce using rule 82 (relational -> exp relational1 .)


state 67

    (84) relational1 -> compare . exp
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    exp                            shift and go to state 96
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 68

    (85) relational1 -> empty .

    AND             reduce using rule 85 (relational1 -> empty .)
    OR              reduce using rule 85 (relational1 -> empty .)
    RBRACKET        reduce using rule 85 (relational1 -> empty .)
    RPAREN          reduce using rule 85 (relational1 -> empty .)
    COMMA           reduce using rule 85 (relational1 -> empty .)
    SEMICOLON       reduce using rule 85 (relational1 -> empty .)


state 69

    (86) compare -> LESSTHAN .

    LPAREN          reduce using rule 86 (compare -> LESSTHAN .)
    ID              reduce using rule 86 (compare -> LESSTHAN .)
    CTE_INT         reduce using rule 86 (compare -> LESSTHAN .)
    CTE_FLOAT       reduce using rule 86 (compare -> LESSTHAN .)
    CTE_CHAR        reduce using rule 86 (compare -> LESSTHAN .)
    CTE_BOOL        reduce using rule 86 (compare -> LESSTHAN .)
    LEN             reduce using rule 86 (compare -> LESSTHAN .)


state 70

    (87) compare -> GREATERTHAN .

    LPAREN          reduce using rule 87 (compare -> GREATERTHAN .)
    ID              reduce using rule 87 (compare -> GREATERTHAN .)
    CTE_INT         reduce using rule 87 (compare -> GREATERTHAN .)
    CTE_FLOAT       reduce using rule 87 (compare -> GREATERTHAN .)
    CTE_CHAR        reduce using rule 87 (compare -> GREATERTHAN .)
    CTE_BOOL        reduce using rule 87 (compare -> GREATERTHAN .)
    LEN             reduce using rule 87 (compare -> GREATERTHAN .)


state 71

    (88) compare -> EQUALS .

    LPAREN          reduce using rule 88 (compare -> EQUALS .)
    ID              reduce using rule 88 (compare -> EQUALS .)
    CTE_INT         reduce using rule 88 (compare -> EQUALS .)
    CTE_FLOAT       reduce using rule 88 (compare -> EQUALS .)
    CTE_CHAR        reduce using rule 88 (compare -> EQUALS .)
    CTE_BOOL        reduce using rule 88 (compare -> EQUALS .)
    LEN             reduce using rule 88 (compare -> EQUALS .)


state 72

    (89) compare -> NOTEQUALS .

    LPAREN          reduce using rule 89 (compare -> NOTEQUALS .)
    ID              reduce using rule 89 (compare -> NOTEQUALS .)
    CTE_INT         reduce using rule 89 (compare -> NOTEQUALS .)
    CTE_FLOAT       reduce using rule 89 (compare -> NOTEQUALS .)
    CTE_CHAR        reduce using rule 89 (compare -> NOTEQUALS .)
    CTE_BOOL        reduce using rule 89 (compare -> NOTEQUALS .)
    LEN             reduce using rule 89 (compare -> NOTEQUALS .)


state 73

    (90) exp -> term exp1 .

    LESSTHAN        reduce using rule 90 (exp -> term exp1 .)
    GREATERTHAN     reduce using rule 90 (exp -> term exp1 .)
    EQUALS          reduce using rule 90 (exp -> term exp1 .)
    NOTEQUALS       reduce using rule 90 (exp -> term exp1 .)
    AND             reduce using rule 90 (exp -> term exp1 .)
    OR              reduce using rule 90 (exp -> term exp1 .)
    RBRACKET        reduce using rule 90 (exp -> term exp1 .)
    RPAREN          reduce using rule 90 (exp -> term exp1 .)
    COMMA           reduce using rule 90 (exp -> term exp1 .)
    SEMICOLON       reduce using rule 90 (exp -> term exp1 .)


state 74

    (91) exp1 -> plusminus . exp
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    exp                            shift and go to state 97
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 75

    (92) exp1 -> empty .

    LESSTHAN        reduce using rule 92 (exp1 -> empty .)
    GREATERTHAN     reduce using rule 92 (exp1 -> empty .)
    EQUALS          reduce using rule 92 (exp1 -> empty .)
    NOTEQUALS       reduce using rule 92 (exp1 -> empty .)
    AND             reduce using rule 92 (exp1 -> empty .)
    OR              reduce using rule 92 (exp1 -> empty .)
    RBRACKET        reduce using rule 92 (exp1 -> empty .)
    RPAREN          reduce using rule 92 (exp1 -> empty .)
    COMMA           reduce using rule 92 (exp1 -> empty .)
    SEMICOLON       reduce using rule 92 (exp1 -> empty .)


state 76

    (93) plusminus -> PLUS .

    LPAREN          reduce using rule 93 (plusminus -> PLUS .)
    ID              reduce using rule 93 (plusminus -> PLUS .)
    CTE_INT         reduce using rule 93 (plusminus -> PLUS .)
    CTE_FLOAT       reduce using rule 93 (plusminus -> PLUS .)
    CTE_CHAR        reduce using rule 93 (plusminus -> PLUS .)
    CTE_BOOL        reduce using rule 93 (plusminus -> PLUS .)
    LEN             reduce using rule 93 (plusminus -> PLUS .)


state 77

    (94) plusminus -> MINUS .

    LPAREN          reduce using rule 94 (plusminus -> MINUS .)
    ID              reduce using rule 94 (plusminus -> MINUS .)
    CTE_INT         reduce using rule 94 (plusminus -> MINUS .)
    CTE_FLOAT       reduce using rule 94 (plusminus -> MINUS .)
    CTE_CHAR        reduce using rule 94 (plusminus -> MINUS .)
    CTE_BOOL        reduce using rule 94 (plusminus -> MINUS .)
    LEN             reduce using rule 94 (plusminus -> MINUS .)


state 78

    (95) term -> factor term1 .

    PLUS            reduce using rule 95 (term -> factor term1 .)
    MINUS           reduce using rule 95 (term -> factor term1 .)
    LESSTHAN        reduce using rule 95 (term -> factor term1 .)
    GREATERTHAN     reduce using rule 95 (term -> factor term1 .)
    EQUALS          reduce using rule 95 (term -> factor term1 .)
    NOTEQUALS       reduce using rule 95 (term -> factor term1 .)
    AND             reduce using rule 95 (term -> factor term1 .)
    OR              reduce using rule 95 (term -> factor term1 .)
    RBRACKET        reduce using rule 95 (term -> factor term1 .)
    RPAREN          reduce using rule 95 (term -> factor term1 .)
    COMMA           reduce using rule 95 (term -> factor term1 .)
    SEMICOLON       reduce using rule 95 (term -> factor term1 .)


state 79

    (96) term1 -> multidivi . term
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    term                           shift and go to state 98
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 80

    (97) term1 -> empty .

    PLUS            reduce using rule 97 (term1 -> empty .)
    MINUS           reduce using rule 97 (term1 -> empty .)
    LESSTHAN        reduce using rule 97 (term1 -> empty .)
    GREATERTHAN     reduce using rule 97 (term1 -> empty .)
    EQUALS          reduce using rule 97 (term1 -> empty .)
    NOTEQUALS       reduce using rule 97 (term1 -> empty .)
    AND             reduce using rule 97 (term1 -> empty .)
    OR              reduce using rule 97 (term1 -> empty .)
    RBRACKET        reduce using rule 97 (term1 -> empty .)
    RPAREN          reduce using rule 97 (term1 -> empty .)
    COMMA           reduce using rule 97 (term1 -> empty .)
    SEMICOLON       reduce using rule 97 (term1 -> empty .)


state 81

    (98) multidivi -> MULTI .

    LPAREN          reduce using rule 98 (multidivi -> MULTI .)
    ID              reduce using rule 98 (multidivi -> MULTI .)
    CTE_INT         reduce using rule 98 (multidivi -> MULTI .)
    CTE_FLOAT       reduce using rule 98 (multidivi -> MULTI .)
    CTE_CHAR        reduce using rule 98 (multidivi -> MULTI .)
    CTE_BOOL        reduce using rule 98 (multidivi -> MULTI .)
    LEN             reduce using rule 98 (multidivi -> MULTI .)


state 82

    (99) multidivi -> DIVI .

    LPAREN          reduce using rule 99 (multidivi -> DIVI .)
    ID              reduce using rule 99 (multidivi -> DIVI .)
    CTE_INT         reduce using rule 99 (multidivi -> DIVI .)
    CTE_FLOAT       reduce using rule 99 (multidivi -> DIVI .)
    CTE_CHAR        reduce using rule 99 (multidivi -> DIVI .)
    CTE_BOOL        reduce using rule 99 (multidivi -> DIVI .)
    LEN             reduce using rule 99 (multidivi -> DIVI .)


state 83

    (100) factor -> LPAREN insertfloor . express RPAREN endfloor
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 99
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 84

    (104) insertfloor -> empty .

    NOT             reduce using rule 104 (insertfloor -> empty .)
    LPAREN          reduce using rule 104 (insertfloor -> empty .)
    ID              reduce using rule 104 (insertfloor -> empty .)
    CTE_INT         reduce using rule 104 (insertfloor -> empty .)
    CTE_FLOAT       reduce using rule 104 (insertfloor -> empty .)
    CTE_CHAR        reduce using rule 104 (insertfloor -> empty .)
    CTE_BOOL        reduce using rule 104 (insertfloor -> empty .)
    LEN             reduce using rule 104 (insertfloor -> empty .)
    RPAREN          reduce using rule 104 (insertfloor -> empty .)


state 85

    (69) constant -> ID punto . array
    (74) array -> . LBRACKET insertfloor express RBRACKET endfloor
    (75) array -> . empty
    (106) empty -> .

    LBRACKET        shift and go to state 101
    MULTI           reduce using rule 106 (empty -> .)
    DIVI            reduce using rule 106 (empty -> .)
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    LESSTHAN        reduce using rule 106 (empty -> .)
    GREATERTHAN     reduce using rule 106 (empty -> .)
    EQUALS          reduce using rule 106 (empty -> .)
    NOTEQUALS       reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    RBRACKET        reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    SEMICOLON       reduce using rule 106 (empty -> .)

    array                          shift and go to state 100
    empty                          shift and go to state 102

state 86

    (76) punto -> empty .

    LBRACKET        reduce using rule 76 (punto -> empty .)
    MULTI           reduce using rule 76 (punto -> empty .)
    DIVI            reduce using rule 76 (punto -> empty .)
    PLUS            reduce using rule 76 (punto -> empty .)
    MINUS           reduce using rule 76 (punto -> empty .)
    LESSTHAN        reduce using rule 76 (punto -> empty .)
    GREATERTHAN     reduce using rule 76 (punto -> empty .)
    EQUALS          reduce using rule 76 (punto -> empty .)
    NOTEQUALS       reduce using rule 76 (punto -> empty .)
    AND             reduce using rule 76 (punto -> empty .)
    OR              reduce using rule 76 (punto -> empty .)
    RBRACKET        reduce using rule 76 (punto -> empty .)
    RPAREN          reduce using rule 76 (punto -> empty .)
    COMMA           reduce using rule 76 (punto -> empty .)
    SEMICOLON       reduce using rule 76 (punto -> empty .)
    ASSIGN          reduce using rule 76 (punto -> empty .)


state 87

    (43) call -> era LPAREN . insertfloor paramcall RPAREN endfloor
    (104) insertfloor -> . empty
    (106) empty -> .

    NOT             reduce using rule 106 (empty -> .)
    LPAREN          reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CTE_INT         reduce using rule 106 (empty -> .)
    CTE_FLOAT       reduce using rule 106 (empty -> .)
    CTE_CHAR        reduce using rule 106 (empty -> .)
    CTE_BOOL        reduce using rule 106 (empty -> .)
    LEN             reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)

    insertfloor                    shift and go to state 103
    empty                          shift and go to state 84

state 88

    (63) len -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 104


state 89

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY . varsblock main1 block RCURLY
    (11) varsblock -> . vars varsblock
    (12) varsblock -> . empty
    (13) vars -> . VARDEF type ID dimvar SEMICOLON
    (106) empty -> .

    VARDEF          shift and go to state 8
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CIN             reduce using rule 106 (empty -> .)
    COUT            reduce using rule 106 (empty -> .)
    DELAY           reduce using rule 106 (empty -> .)
    FORWARD         reduce using rule 106 (empty -> .)
    BACKWARD        reduce using rule 106 (empty -> .)
    TURNLEFT        reduce using rule 106 (empty -> .)
    TURNRIGHT       reduce using rule 106 (empty -> .)
    SERVO           reduce using rule 106 (empty -> .)
    LIGHTS          reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    RETURN          reduce using rule 106 (empty -> .)
    RCURLY          reduce using rule 106 (empty -> .)

    varsblock                      shift and go to state 105
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 90

    (19) params -> type ID .

    COMMA           reduce using rule 19 (params -> type ID .)
    INT             reduce using rule 19 (params -> type ID .)
    FLOAT           reduce using rule 19 (params -> type ID .)
    BOOL            reduce using rule 19 (params -> type ID .)
    CHAR            reduce using rule 19 (params -> type ID .)
    VOID            reduce using rule 19 (params -> type ID .)
    RPAREN          reduce using rule 19 (params -> type ID .)


state 91

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN . LCURLY varsblock funcs1 block RCURLY

    LCURLY          shift and go to state 106


state 92

    (16) paramsblock -> params paramsblock .

    RPAREN          reduce using rule 16 (paramsblock -> params paramsblock .)


state 93

    (17) paramsblock -> COMMA params . paramsblock
    (16) paramsblock -> . params paramsblock
    (17) paramsblock -> . COMMA params paramsblock
    (18) paramsblock -> . empty
    (19) params -> . type ID
    (20) params -> . empty
    (106) empty -> .
    (64) type -> . INT
    (65) type -> . FLOAT
    (66) type -> . BOOL
    (67) type -> . CHAR
    (68) type -> . VOID

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMA           shift and go to state 58
    RPAREN          reduce using rule 106 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

  ! COMMA           [ reduce using rule 106 (empty -> .) ]
  ! INT             [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! BOOL            [ reduce using rule 106 (empty -> .) ]
  ! CHAR            [ reduce using rule 106 (empty -> .) ]
  ! VOID            [ reduce using rule 106 (empty -> .) ]

    params                         shift and go to state 57
    paramsblock                    shift and go to state 107
    empty                          shift and go to state 59
    type                           shift and go to state 55

state 94

    (20) params -> empty .

    COMMA           reduce using rule 20 (params -> empty .)
    INT             reduce using rule 20 (params -> empty .)
    FLOAT           reduce using rule 20 (params -> empty .)
    BOOL            reduce using rule 20 (params -> empty .)
    CHAR            reduce using rule 20 (params -> empty .)
    VOID            reduce using rule 20 (params -> empty .)
    RPAREN          reduce using rule 20 (params -> empty .)


state 95

    (78) express1 -> andor express .

    RBRACKET        reduce using rule 78 (express1 -> andor express .)
    RPAREN          reduce using rule 78 (express1 -> andor express .)
    COMMA           reduce using rule 78 (express1 -> andor express .)
    SEMICOLON       reduce using rule 78 (express1 -> andor express .)


state 96

    (84) relational1 -> compare exp .

    AND             reduce using rule 84 (relational1 -> compare exp .)
    OR              reduce using rule 84 (relational1 -> compare exp .)
    RBRACKET        reduce using rule 84 (relational1 -> compare exp .)
    RPAREN          reduce using rule 84 (relational1 -> compare exp .)
    COMMA           reduce using rule 84 (relational1 -> compare exp .)
    SEMICOLON       reduce using rule 84 (relational1 -> compare exp .)


state 97

    (91) exp1 -> plusminus exp .

    LESSTHAN        reduce using rule 91 (exp1 -> plusminus exp .)
    GREATERTHAN     reduce using rule 91 (exp1 -> plusminus exp .)
    EQUALS          reduce using rule 91 (exp1 -> plusminus exp .)
    NOTEQUALS       reduce using rule 91 (exp1 -> plusminus exp .)
    AND             reduce using rule 91 (exp1 -> plusminus exp .)
    OR              reduce using rule 91 (exp1 -> plusminus exp .)
    RBRACKET        reduce using rule 91 (exp1 -> plusminus exp .)
    RPAREN          reduce using rule 91 (exp1 -> plusminus exp .)
    COMMA           reduce using rule 91 (exp1 -> plusminus exp .)
    SEMICOLON       reduce using rule 91 (exp1 -> plusminus exp .)


state 98

    (96) term1 -> multidivi term .

    PLUS            reduce using rule 96 (term1 -> multidivi term .)
    MINUS           reduce using rule 96 (term1 -> multidivi term .)
    LESSTHAN        reduce using rule 96 (term1 -> multidivi term .)
    GREATERTHAN     reduce using rule 96 (term1 -> multidivi term .)
    EQUALS          reduce using rule 96 (term1 -> multidivi term .)
    NOTEQUALS       reduce using rule 96 (term1 -> multidivi term .)
    AND             reduce using rule 96 (term1 -> multidivi term .)
    OR              reduce using rule 96 (term1 -> multidivi term .)
    RBRACKET        reduce using rule 96 (term1 -> multidivi term .)
    RPAREN          reduce using rule 96 (term1 -> multidivi term .)
    COMMA           reduce using rule 96 (term1 -> multidivi term .)
    SEMICOLON       reduce using rule 96 (term1 -> multidivi term .)


state 99

    (100) factor -> LPAREN insertfloor express . RPAREN endfloor

    RPAREN          shift and go to state 108


state 100

    (69) constant -> ID punto array .

    MULTI           reduce using rule 69 (constant -> ID punto array .)
    DIVI            reduce using rule 69 (constant -> ID punto array .)
    PLUS            reduce using rule 69 (constant -> ID punto array .)
    MINUS           reduce using rule 69 (constant -> ID punto array .)
    LESSTHAN        reduce using rule 69 (constant -> ID punto array .)
    GREATERTHAN     reduce using rule 69 (constant -> ID punto array .)
    EQUALS          reduce using rule 69 (constant -> ID punto array .)
    NOTEQUALS       reduce using rule 69 (constant -> ID punto array .)
    AND             reduce using rule 69 (constant -> ID punto array .)
    OR              reduce using rule 69 (constant -> ID punto array .)
    RBRACKET        reduce using rule 69 (constant -> ID punto array .)
    RPAREN          reduce using rule 69 (constant -> ID punto array .)
    COMMA           reduce using rule 69 (constant -> ID punto array .)
    SEMICOLON       reduce using rule 69 (constant -> ID punto array .)


state 101

    (74) array -> LBRACKET . insertfloor express RBRACKET endfloor
    (104) insertfloor -> . empty
    (106) empty -> .

    NOT             reduce using rule 106 (empty -> .)
    LPAREN          reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CTE_INT         reduce using rule 106 (empty -> .)
    CTE_FLOAT       reduce using rule 106 (empty -> .)
    CTE_CHAR        reduce using rule 106 (empty -> .)
    CTE_BOOL        reduce using rule 106 (empty -> .)
    LEN             reduce using rule 106 (empty -> .)

    insertfloor                    shift and go to state 109
    empty                          shift and go to state 84

state 102

    (75) array -> empty .

    MULTI           reduce using rule 75 (array -> empty .)
    DIVI            reduce using rule 75 (array -> empty .)
    PLUS            reduce using rule 75 (array -> empty .)
    MINUS           reduce using rule 75 (array -> empty .)
    LESSTHAN        reduce using rule 75 (array -> empty .)
    GREATERTHAN     reduce using rule 75 (array -> empty .)
    EQUALS          reduce using rule 75 (array -> empty .)
    NOTEQUALS       reduce using rule 75 (array -> empty .)
    AND             reduce using rule 75 (array -> empty .)
    OR              reduce using rule 75 (array -> empty .)
    RBRACKET        reduce using rule 75 (array -> empty .)
    RPAREN          reduce using rule 75 (array -> empty .)
    COMMA           reduce using rule 75 (array -> empty .)
    SEMICOLON       reduce using rule 75 (array -> empty .)
    ASSIGN          reduce using rule 75 (array -> empty .)


state 103

    (43) call -> era LPAREN insertfloor . paramcall RPAREN endfloor
    (45) paramcall -> . express paramcall1
    (46) paramcall -> . empty
    (77) express -> . relational express1
    (106) empty -> .
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    RPAREN          reduce using rule 106 (empty -> .)
    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    era                            shift and go to state 52
    paramcall                      shift and go to state 110
    express                        shift and go to state 111
    empty                          shift and go to state 112
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46

state 104

    (63) len -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 113


state 105

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock . main1 block RCURLY
    (4) main1 -> . empty
    (106) empty -> .

    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CIN             reduce using rule 106 (empty -> .)
    COUT            reduce using rule 106 (empty -> .)
    DELAY           reduce using rule 106 (empty -> .)
    FORWARD         reduce using rule 106 (empty -> .)
    BACKWARD        reduce using rule 106 (empty -> .)
    TURNLEFT        reduce using rule 106 (empty -> .)
    TURNRIGHT       reduce using rule 106 (empty -> .)
    SERVO           reduce using rule 106 (empty -> .)
    LIGHTS          reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    RETURN          reduce using rule 106 (empty -> .)
    RCURLY          reduce using rule 106 (empty -> .)

    main1                          shift and go to state 114
    empty                          shift and go to state 115

state 106

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY . varsblock funcs1 block RCURLY
    (11) varsblock -> . vars varsblock
    (12) varsblock -> . empty
    (13) vars -> . VARDEF type ID dimvar SEMICOLON
    (106) empty -> .

    VARDEF          shift and go to state 8
    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CIN             reduce using rule 106 (empty -> .)
    COUT            reduce using rule 106 (empty -> .)
    DELAY           reduce using rule 106 (empty -> .)
    FORWARD         reduce using rule 106 (empty -> .)
    BACKWARD        reduce using rule 106 (empty -> .)
    TURNLEFT        reduce using rule 106 (empty -> .)
    TURNRIGHT       reduce using rule 106 (empty -> .)
    SERVO           reduce using rule 106 (empty -> .)
    LIGHTS          reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    RETURN          reduce using rule 106 (empty -> .)
    RCURLY          reduce using rule 106 (empty -> .)

    varsblock                      shift and go to state 116
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 107

    (17) paramsblock -> COMMA params paramsblock .

    RPAREN          reduce using rule 17 (paramsblock -> COMMA params paramsblock .)


state 108

    (100) factor -> LPAREN insertfloor express RPAREN . endfloor
    (105) endfloor -> . empty
    (106) empty -> .

    MULTI           reduce using rule 106 (empty -> .)
    DIVI            reduce using rule 106 (empty -> .)
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    LESSTHAN        reduce using rule 106 (empty -> .)
    GREATERTHAN     reduce using rule 106 (empty -> .)
    EQUALS          reduce using rule 106 (empty -> .)
    NOTEQUALS       reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    RBRACKET        reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    SEMICOLON       reduce using rule 106 (empty -> .)

    endfloor                       shift and go to state 117
    empty                          shift and go to state 118

state 109

    (74) array -> LBRACKET insertfloor . express RBRACKET endfloor
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 119
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 110

    (43) call -> era LPAREN insertfloor paramcall . RPAREN endfloor

    RPAREN          shift and go to state 120


state 111

    (45) paramcall -> express . paramcall1
    (47) paramcall1 -> . COMMA paramcall
    (48) paramcall1 -> . empty
    (106) empty -> .

    COMMA           shift and go to state 122
    RPAREN          reduce using rule 106 (empty -> .)

    paramcall1                     shift and go to state 121
    empty                          shift and go to state 123

state 112

    (46) paramcall -> empty .

    RPAREN          reduce using rule 46 (paramcall -> empty .)


state 113

    (63) len -> LEN LPAREN ID RPAREN .

    MULTI           reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    DIVI            reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    PLUS            reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    MINUS           reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    LESSTHAN        reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    GREATERTHAN     reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    EQUALS          reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    NOTEQUALS       reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    AND             reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    OR              reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    RBRACKET        reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    RPAREN          reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    COMMA           reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)
    SEMICOLON       reduce using rule 63 (len -> LEN LPAREN ID RPAREN .)


state 114

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 . block RCURLY
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . while
    (36) statute -> . return
    (106) empty -> .
    (37) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (42) assign -> . ID punto array ASSIGN express
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (49) cin -> . CIN LPAREN express RPAREN
    (50) cout -> . COUT LPAREN express cout1 RPAREN
    (53) delay -> . DELAY LPAREN express RPAREN
    (54) forward -> . FORWARD LPAREN express RPAREN
    (55) backward -> . BACKWARD LPAREN express RPAREN
    (56) turnleft -> . TURNLEFT LPAREN express RPAREN
    (57) turnright -> . TURNRIGHT LPAREN express RPAREN
    (58) servo -> . SERVO LPAREN express RPAREN
    (59) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (60) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (62) return -> . RETURN LPAREN express RPAREN
    (44) era -> . ID

    RCURLY          reduce using rule 106 (empty -> .)
    IF              shift and go to state 141
    ID              shift and go to state 142
    CIN             shift and go to state 143
    COUT            shift and go to state 144
    DELAY           shift and go to state 145
    FORWARD         shift and go to state 146
    BACKWARD        shift and go to state 147
    TURNLEFT        shift and go to state 148
    TURNRIGHT       shift and go to state 149
    SERVO           shift and go to state 150
    LIGHTS          shift and go to state 151
    WHILE           shift and go to state 152
    RETURN          shift and go to state 153

    block                          shift and go to state 124
    statute                        shift and go to state 125
    empty                          shift and go to state 126
    cond                           shift and go to state 127
    assign                         shift and go to state 128
    call                           shift and go to state 129
    cin                            shift and go to state 130
    cout                           shift and go to state 131
    delay                          shift and go to state 132
    forward                        shift and go to state 133
    backward                       shift and go to state 134
    turnleft                       shift and go to state 135
    turnright                      shift and go to state 136
    servo                          shift and go to state 137
    lights                         shift and go to state 138
    while                          shift and go to state 139
    return                         shift and go to state 140
    era                            shift and go to state 52

state 115

    (4) main1 -> empty .

    IF              reduce using rule 4 (main1 -> empty .)
    ID              reduce using rule 4 (main1 -> empty .)
    CIN             reduce using rule 4 (main1 -> empty .)
    COUT            reduce using rule 4 (main1 -> empty .)
    DELAY           reduce using rule 4 (main1 -> empty .)
    FORWARD         reduce using rule 4 (main1 -> empty .)
    BACKWARD        reduce using rule 4 (main1 -> empty .)
    TURNLEFT        reduce using rule 4 (main1 -> empty .)
    TURNRIGHT       reduce using rule 4 (main1 -> empty .)
    SERVO           reduce using rule 4 (main1 -> empty .)
    LIGHTS          reduce using rule 4 (main1 -> empty .)
    WHILE           reduce using rule 4 (main1 -> empty .)
    RETURN          reduce using rule 4 (main1 -> empty .)
    RCURLY          reduce using rule 4 (main1 -> empty .)


state 116

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock . funcs1 block RCURLY
    (9) funcs1 -> . empty
    (106) empty -> .

    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CIN             reduce using rule 106 (empty -> .)
    COUT            reduce using rule 106 (empty -> .)
    DELAY           reduce using rule 106 (empty -> .)
    FORWARD         reduce using rule 106 (empty -> .)
    BACKWARD        reduce using rule 106 (empty -> .)
    TURNLEFT        reduce using rule 106 (empty -> .)
    TURNRIGHT       reduce using rule 106 (empty -> .)
    SERVO           reduce using rule 106 (empty -> .)
    LIGHTS          reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    RETURN          reduce using rule 106 (empty -> .)
    RCURLY          reduce using rule 106 (empty -> .)

    funcs1                         shift and go to state 154
    empty                          shift and go to state 155

state 117

    (100) factor -> LPAREN insertfloor express RPAREN endfloor .

    MULTI           reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    DIVI            reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    PLUS            reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    MINUS           reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    LESSTHAN        reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    GREATERTHAN     reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    EQUALS          reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    NOTEQUALS       reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    AND             reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    OR              reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    RBRACKET        reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    RPAREN          reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    COMMA           reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    SEMICOLON       reduce using rule 100 (factor -> LPAREN insertfloor express RPAREN endfloor .)


state 118

    (105) endfloor -> empty .

    MULTI           reduce using rule 105 (endfloor -> empty .)
    DIVI            reduce using rule 105 (endfloor -> empty .)
    PLUS            reduce using rule 105 (endfloor -> empty .)
    MINUS           reduce using rule 105 (endfloor -> empty .)
    LESSTHAN        reduce using rule 105 (endfloor -> empty .)
    GREATERTHAN     reduce using rule 105 (endfloor -> empty .)
    EQUALS          reduce using rule 105 (endfloor -> empty .)
    NOTEQUALS       reduce using rule 105 (endfloor -> empty .)
    AND             reduce using rule 105 (endfloor -> empty .)
    OR              reduce using rule 105 (endfloor -> empty .)
    RBRACKET        reduce using rule 105 (endfloor -> empty .)
    RPAREN          reduce using rule 105 (endfloor -> empty .)
    COMMA           reduce using rule 105 (endfloor -> empty .)
    SEMICOLON       reduce using rule 105 (endfloor -> empty .)
    ASSIGN          reduce using rule 105 (endfloor -> empty .)


state 119

    (74) array -> LBRACKET insertfloor express . RBRACKET endfloor

    RBRACKET        shift and go to state 156


state 120

    (43) call -> era LPAREN insertfloor paramcall RPAREN . endfloor
    (105) endfloor -> . empty
    (106) empty -> .

    MULTI           reduce using rule 106 (empty -> .)
    DIVI            reduce using rule 106 (empty -> .)
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    LESSTHAN        reduce using rule 106 (empty -> .)
    GREATERTHAN     reduce using rule 106 (empty -> .)
    EQUALS          reduce using rule 106 (empty -> .)
    NOTEQUALS       reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    RBRACKET        reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    SEMICOLON       reduce using rule 106 (empty -> .)

    endfloor                       shift and go to state 157
    empty                          shift and go to state 118

state 121

    (45) paramcall -> express paramcall1 .

    RPAREN          reduce using rule 45 (paramcall -> express paramcall1 .)


state 122

    (47) paramcall1 -> COMMA . paramcall
    (45) paramcall -> . express paramcall1
    (46) paramcall -> . empty
    (77) express -> . relational express1
    (106) empty -> .
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    RPAREN          reduce using rule 106 (empty -> .)
    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    paramcall                      shift and go to state 158
    express                        shift and go to state 111
    empty                          shift and go to state 112
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 123

    (48) paramcall1 -> empty .

    RPAREN          reduce using rule 48 (paramcall1 -> empty .)


state 124

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block . RCURLY

    RCURLY          shift and go to state 159


state 125

    (21) block -> statute . SEMICOLON block

    SEMICOLON       shift and go to state 160


state 126

    (22) block -> empty .

    RCURLY          reduce using rule 22 (block -> empty .)


state 127

    (23) statute -> cond .

    SEMICOLON       reduce using rule 23 (statute -> cond .)


state 128

    (24) statute -> assign .

    SEMICOLON       reduce using rule 24 (statute -> assign .)


state 129

    (25) statute -> call .

    SEMICOLON       reduce using rule 25 (statute -> call .)


state 130

    (26) statute -> cin .

    SEMICOLON       reduce using rule 26 (statute -> cin .)


state 131

    (27) statute -> cout .

    SEMICOLON       reduce using rule 27 (statute -> cout .)


state 132

    (28) statute -> delay .

    SEMICOLON       reduce using rule 28 (statute -> delay .)


state 133

    (29) statute -> forward .

    SEMICOLON       reduce using rule 29 (statute -> forward .)


state 134

    (30) statute -> backward .

    SEMICOLON       reduce using rule 30 (statute -> backward .)


state 135

    (31) statute -> turnleft .

    SEMICOLON       reduce using rule 31 (statute -> turnleft .)


state 136

    (32) statute -> turnright .

    SEMICOLON       reduce using rule 32 (statute -> turnright .)


state 137

    (33) statute -> servo .

    SEMICOLON       reduce using rule 33 (statute -> servo .)


state 138

    (34) statute -> lights .

    SEMICOLON       reduce using rule 34 (statute -> lights .)


state 139

    (35) statute -> while .

    SEMICOLON       reduce using rule 35 (statute -> while .)


state 140

    (36) statute -> return .

    SEMICOLON       reduce using rule 36 (statute -> return .)


state 141

    (37) cond -> IF . LPAREN express RPAREN LCURLY gotoif block RCURLY else

    LPAREN          shift and go to state 161


state 142

    (42) assign -> ID . punto array ASSIGN express
    (44) era -> ID .
    (76) punto -> . empty
    (106) empty -> .

    LPAREN          reduce using rule 44 (era -> ID .)
    LBRACKET        reduce using rule 106 (empty -> .)
    ASSIGN          reduce using rule 106 (empty -> .)

    punto                          shift and go to state 162
    empty                          shift and go to state 86

state 143

    (49) cin -> CIN . LPAREN express RPAREN

    LPAREN          shift and go to state 163


state 144

    (50) cout -> COUT . LPAREN express cout1 RPAREN

    LPAREN          shift and go to state 164


state 145

    (53) delay -> DELAY . LPAREN express RPAREN

    LPAREN          shift and go to state 165


state 146

    (54) forward -> FORWARD . LPAREN express RPAREN

    LPAREN          shift and go to state 166


state 147

    (55) backward -> BACKWARD . LPAREN express RPAREN

    LPAREN          shift and go to state 167


state 148

    (56) turnleft -> TURNLEFT . LPAREN express RPAREN

    LPAREN          shift and go to state 168


state 149

    (57) turnright -> TURNRIGHT . LPAREN express RPAREN

    LPAREN          shift and go to state 169


state 150

    (58) servo -> SERVO . LPAREN express RPAREN

    LPAREN          shift and go to state 170


state 151

    (59) lights -> LIGHTS . LPAREN express COMMA express RPAREN

    LPAREN          shift and go to state 171


state 152

    (60) while -> WHILE . LPAREN express RPAREN while1 LCURLY block RCURLY

    LPAREN          shift and go to state 172


state 153

    (62) return -> RETURN . LPAREN express RPAREN

    LPAREN          shift and go to state 173


state 154

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 . block RCURLY
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . while
    (36) statute -> . return
    (106) empty -> .
    (37) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (42) assign -> . ID punto array ASSIGN express
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (49) cin -> . CIN LPAREN express RPAREN
    (50) cout -> . COUT LPAREN express cout1 RPAREN
    (53) delay -> . DELAY LPAREN express RPAREN
    (54) forward -> . FORWARD LPAREN express RPAREN
    (55) backward -> . BACKWARD LPAREN express RPAREN
    (56) turnleft -> . TURNLEFT LPAREN express RPAREN
    (57) turnright -> . TURNRIGHT LPAREN express RPAREN
    (58) servo -> . SERVO LPAREN express RPAREN
    (59) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (60) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (62) return -> . RETURN LPAREN express RPAREN
    (44) era -> . ID

    RCURLY          reduce using rule 106 (empty -> .)
    IF              shift and go to state 141
    ID              shift and go to state 142
    CIN             shift and go to state 143
    COUT            shift and go to state 144
    DELAY           shift and go to state 145
    FORWARD         shift and go to state 146
    BACKWARD        shift and go to state 147
    TURNLEFT        shift and go to state 148
    TURNRIGHT       shift and go to state 149
    SERVO           shift and go to state 150
    LIGHTS          shift and go to state 151
    WHILE           shift and go to state 152
    RETURN          shift and go to state 153

    block                          shift and go to state 174
    statute                        shift and go to state 125
    empty                          shift and go to state 126
    cond                           shift and go to state 127
    assign                         shift and go to state 128
    call                           shift and go to state 129
    cin                            shift and go to state 130
    cout                           shift and go to state 131
    delay                          shift and go to state 132
    forward                        shift and go to state 133
    backward                       shift and go to state 134
    turnleft                       shift and go to state 135
    turnright                      shift and go to state 136
    servo                          shift and go to state 137
    lights                         shift and go to state 138
    while                          shift and go to state 139
    return                         shift and go to state 140
    era                            shift and go to state 52

state 155

    (9) funcs1 -> empty .

    IF              reduce using rule 9 (funcs1 -> empty .)
    ID              reduce using rule 9 (funcs1 -> empty .)
    CIN             reduce using rule 9 (funcs1 -> empty .)
    COUT            reduce using rule 9 (funcs1 -> empty .)
    DELAY           reduce using rule 9 (funcs1 -> empty .)
    FORWARD         reduce using rule 9 (funcs1 -> empty .)
    BACKWARD        reduce using rule 9 (funcs1 -> empty .)
    TURNLEFT        reduce using rule 9 (funcs1 -> empty .)
    TURNRIGHT       reduce using rule 9 (funcs1 -> empty .)
    SERVO           reduce using rule 9 (funcs1 -> empty .)
    LIGHTS          reduce using rule 9 (funcs1 -> empty .)
    WHILE           reduce using rule 9 (funcs1 -> empty .)
    RETURN          reduce using rule 9 (funcs1 -> empty .)
    RCURLY          reduce using rule 9 (funcs1 -> empty .)


state 156

    (74) array -> LBRACKET insertfloor express RBRACKET . endfloor
    (105) endfloor -> . empty
    (106) empty -> .

    MULTI           reduce using rule 106 (empty -> .)
    DIVI            reduce using rule 106 (empty -> .)
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    LESSTHAN        reduce using rule 106 (empty -> .)
    GREATERTHAN     reduce using rule 106 (empty -> .)
    EQUALS          reduce using rule 106 (empty -> .)
    NOTEQUALS       reduce using rule 106 (empty -> .)
    AND             reduce using rule 106 (empty -> .)
    OR              reduce using rule 106 (empty -> .)
    RBRACKET        reduce using rule 106 (empty -> .)
    RPAREN          reduce using rule 106 (empty -> .)
    COMMA           reduce using rule 106 (empty -> .)
    SEMICOLON       reduce using rule 106 (empty -> .)
    ASSIGN          reduce using rule 106 (empty -> .)

    endfloor                       shift and go to state 175
    empty                          shift and go to state 118

state 157

    (43) call -> era LPAREN insertfloor paramcall RPAREN endfloor .

    MULTI           reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    DIVI            reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    PLUS            reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    MINUS           reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    LESSTHAN        reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    GREATERTHAN     reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    EQUALS          reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    NOTEQUALS       reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    AND             reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    OR              reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    RBRACKET        reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    RPAREN          reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    COMMA           reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    SEMICOLON       reduce using rule 43 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)


state 158

    (47) paramcall1 -> COMMA paramcall .

    RPAREN          reduce using rule 47 (paramcall1 -> COMMA paramcall .)


state 159

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY .

    FIN             reduce using rule 3 (main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY .)


state 160

    (21) block -> statute SEMICOLON . block
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . while
    (36) statute -> . return
    (106) empty -> .
    (37) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (42) assign -> . ID punto array ASSIGN express
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (49) cin -> . CIN LPAREN express RPAREN
    (50) cout -> . COUT LPAREN express cout1 RPAREN
    (53) delay -> . DELAY LPAREN express RPAREN
    (54) forward -> . FORWARD LPAREN express RPAREN
    (55) backward -> . BACKWARD LPAREN express RPAREN
    (56) turnleft -> . TURNLEFT LPAREN express RPAREN
    (57) turnright -> . TURNRIGHT LPAREN express RPAREN
    (58) servo -> . SERVO LPAREN express RPAREN
    (59) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (60) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (62) return -> . RETURN LPAREN express RPAREN
    (44) era -> . ID

    RCURLY          reduce using rule 106 (empty -> .)
    IF              shift and go to state 141
    ID              shift and go to state 142
    CIN             shift and go to state 143
    COUT            shift and go to state 144
    DELAY           shift and go to state 145
    FORWARD         shift and go to state 146
    BACKWARD        shift and go to state 147
    TURNLEFT        shift and go to state 148
    TURNRIGHT       shift and go to state 149
    SERVO           shift and go to state 150
    LIGHTS          shift and go to state 151
    WHILE           shift and go to state 152
    RETURN          shift and go to state 153

    statute                        shift and go to state 125
    block                          shift and go to state 176
    empty                          shift and go to state 126
    cond                           shift and go to state 127
    assign                         shift and go to state 128
    call                           shift and go to state 129
    cin                            shift and go to state 130
    cout                           shift and go to state 131
    delay                          shift and go to state 132
    forward                        shift and go to state 133
    backward                       shift and go to state 134
    turnleft                       shift and go to state 135
    turnright                      shift and go to state 136
    servo                          shift and go to state 137
    lights                         shift and go to state 138
    while                          shift and go to state 139
    return                         shift and go to state 140
    era                            shift and go to state 52

state 161

    (37) cond -> IF LPAREN . express RPAREN LCURLY gotoif block RCURLY else
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 177
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 162

    (42) assign -> ID punto . array ASSIGN express
    (74) array -> . LBRACKET insertfloor express RBRACKET endfloor
    (75) array -> . empty
    (106) empty -> .

    LBRACKET        shift and go to state 101
    ASSIGN          reduce using rule 106 (empty -> .)

    array                          shift and go to state 178
    empty                          shift and go to state 102

state 163

    (49) cin -> CIN LPAREN . express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 179
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 164

    (50) cout -> COUT LPAREN . express cout1 RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 180
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 165

    (53) delay -> DELAY LPAREN . express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 181
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 166

    (54) forward -> FORWARD LPAREN . express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 182
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 167

    (55) backward -> BACKWARD LPAREN . express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 183
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 168

    (56) turnleft -> TURNLEFT LPAREN . express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 184
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 169

    (57) turnright -> TURNRIGHT LPAREN . express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 185
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 170

    (58) servo -> SERVO LPAREN . express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 186
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 171

    (59) lights -> LIGHTS LPAREN . express COMMA express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 187
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 172

    (60) while -> WHILE LPAREN . express RPAREN while1 LCURLY block RCURLY
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 188
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 173

    (62) return -> RETURN LPAREN . express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 189
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 174

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block . RCURLY

    RCURLY          shift and go to state 190


state 175

    (74) array -> LBRACKET insertfloor express RBRACKET endfloor .

    MULTI           reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    DIVI            reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    PLUS            reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    MINUS           reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    LESSTHAN        reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    GREATERTHAN     reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    EQUALS          reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    NOTEQUALS       reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    AND             reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    OR              reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    RBRACKET        reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    RPAREN          reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    COMMA           reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    SEMICOLON       reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    ASSIGN          reduce using rule 74 (array -> LBRACKET insertfloor express RBRACKET endfloor .)


state 176

    (21) block -> statute SEMICOLON block .

    RCURLY          reduce using rule 21 (block -> statute SEMICOLON block .)


state 177

    (37) cond -> IF LPAREN express . RPAREN LCURLY gotoif block RCURLY else

    RPAREN          shift and go to state 191


state 178

    (42) assign -> ID punto array . ASSIGN express

    ASSIGN          shift and go to state 192


state 179

    (49) cin -> CIN LPAREN express . RPAREN

    RPAREN          shift and go to state 193


state 180

    (50) cout -> COUT LPAREN express . cout1 RPAREN
    (51) cout1 -> . COMMA express cout1
    (52) cout1 -> . empty
    (106) empty -> .

    COMMA           shift and go to state 195
    RPAREN          reduce using rule 106 (empty -> .)

    cout1                          shift and go to state 194
    empty                          shift and go to state 196

state 181

    (53) delay -> DELAY LPAREN express . RPAREN

    RPAREN          shift and go to state 197


state 182

    (54) forward -> FORWARD LPAREN express . RPAREN

    RPAREN          shift and go to state 198


state 183

    (55) backward -> BACKWARD LPAREN express . RPAREN

    RPAREN          shift and go to state 199


state 184

    (56) turnleft -> TURNLEFT LPAREN express . RPAREN

    RPAREN          shift and go to state 200


state 185

    (57) turnright -> TURNRIGHT LPAREN express . RPAREN

    RPAREN          shift and go to state 201


state 186

    (58) servo -> SERVO LPAREN express . RPAREN

    RPAREN          shift and go to state 202


state 187

    (59) lights -> LIGHTS LPAREN express . COMMA express RPAREN

    COMMA           shift and go to state 203


state 188

    (60) while -> WHILE LPAREN express . RPAREN while1 LCURLY block RCURLY

    RPAREN          shift and go to state 204


state 189

    (62) return -> RETURN LPAREN express . RPAREN

    RPAREN          shift and go to state 205


state 190

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY .

    FUNCDEF         reduce using rule 8 (funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY .)
    MAIN            reduce using rule 8 (funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY .)


state 191

    (37) cond -> IF LPAREN express RPAREN . LCURLY gotoif block RCURLY else

    LCURLY          shift and go to state 206


state 192

    (42) assign -> ID punto array ASSIGN . express
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 207
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 193

    (49) cin -> CIN LPAREN express RPAREN .

    SEMICOLON       reduce using rule 49 (cin -> CIN LPAREN express RPAREN .)


state 194

    (50) cout -> COUT LPAREN express cout1 . RPAREN

    RPAREN          shift and go to state 208


state 195

    (51) cout1 -> COMMA . express cout1
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 209
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 196

    (52) cout1 -> empty .

    RPAREN          reduce using rule 52 (cout1 -> empty .)


state 197

    (53) delay -> DELAY LPAREN express RPAREN .

    SEMICOLON       reduce using rule 53 (delay -> DELAY LPAREN express RPAREN .)


state 198

    (54) forward -> FORWARD LPAREN express RPAREN .

    SEMICOLON       reduce using rule 54 (forward -> FORWARD LPAREN express RPAREN .)


state 199

    (55) backward -> BACKWARD LPAREN express RPAREN .

    SEMICOLON       reduce using rule 55 (backward -> BACKWARD LPAREN express RPAREN .)


state 200

    (56) turnleft -> TURNLEFT LPAREN express RPAREN .

    SEMICOLON       reduce using rule 56 (turnleft -> TURNLEFT LPAREN express RPAREN .)


state 201

    (57) turnright -> TURNRIGHT LPAREN express RPAREN .

    SEMICOLON       reduce using rule 57 (turnright -> TURNRIGHT LPAREN express RPAREN .)


state 202

    (58) servo -> SERVO LPAREN express RPAREN .

    SEMICOLON       reduce using rule 58 (servo -> SERVO LPAREN express RPAREN .)


state 203

    (59) lights -> LIGHTS LPAREN express COMMA . express RPAREN
    (77) express -> . relational express1
    (82) relational -> . exp relational1
    (83) relational -> . NOT
    (90) exp -> . term exp1
    (95) term -> . factor term1
    (100) factor -> . LPAREN insertfloor express RPAREN endfloor
    (101) factor -> . constant
    (102) factor -> . call
    (103) factor -> . len
    (69) constant -> . ID punto array
    (70) constant -> . CTE_INT
    (71) constant -> . CTE_FLOAT
    (72) constant -> . CTE_CHAR
    (73) constant -> . CTE_BOOL
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (63) len -> . LEN LPAREN ID RPAREN
    (44) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 47
    CTE_INT         shift and go to state 48
    CTE_FLOAT       shift and go to state 49
    CTE_CHAR        shift and go to state 50
    CTE_BOOL        shift and go to state 51
    LEN             shift and go to state 53

    express                        shift and go to state 210
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    len                            shift and go to state 46
    era                            shift and go to state 52

state 204

    (60) while -> WHILE LPAREN express RPAREN . while1 LCURLY block RCURLY
    (61) while1 -> . empty
    (106) empty -> .

    LCURLY          reduce using rule 106 (empty -> .)

    while1                         shift and go to state 211
    empty                          shift and go to state 212

state 205

    (62) return -> RETURN LPAREN express RPAREN .

    SEMICOLON       reduce using rule 62 (return -> RETURN LPAREN express RPAREN .)


state 206

    (37) cond -> IF LPAREN express RPAREN LCURLY . gotoif block RCURLY else
    (38) gotoif -> . empty
    (106) empty -> .

    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CIN             reduce using rule 106 (empty -> .)
    COUT            reduce using rule 106 (empty -> .)
    DELAY           reduce using rule 106 (empty -> .)
    FORWARD         reduce using rule 106 (empty -> .)
    BACKWARD        reduce using rule 106 (empty -> .)
    TURNLEFT        reduce using rule 106 (empty -> .)
    TURNRIGHT       reduce using rule 106 (empty -> .)
    SERVO           reduce using rule 106 (empty -> .)
    LIGHTS          reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    RETURN          reduce using rule 106 (empty -> .)
    RCURLY          reduce using rule 106 (empty -> .)

    gotoif                         shift and go to state 213
    empty                          shift and go to state 214

state 207

    (42) assign -> ID punto array ASSIGN express .

    SEMICOLON       reduce using rule 42 (assign -> ID punto array ASSIGN express .)


state 208

    (50) cout -> COUT LPAREN express cout1 RPAREN .

    SEMICOLON       reduce using rule 50 (cout -> COUT LPAREN express cout1 RPAREN .)


state 209

    (51) cout1 -> COMMA express . cout1
    (51) cout1 -> . COMMA express cout1
    (52) cout1 -> . empty
    (106) empty -> .

    COMMA           shift and go to state 195
    RPAREN          reduce using rule 106 (empty -> .)

    cout1                          shift and go to state 215
    empty                          shift and go to state 196

state 210

    (59) lights -> LIGHTS LPAREN express COMMA express . RPAREN

    RPAREN          shift and go to state 216


state 211

    (60) while -> WHILE LPAREN express RPAREN while1 . LCURLY block RCURLY

    LCURLY          shift and go to state 217


state 212

    (61) while1 -> empty .

    LCURLY          reduce using rule 61 (while1 -> empty .)


state 213

    (37) cond -> IF LPAREN express RPAREN LCURLY gotoif . block RCURLY else
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . while
    (36) statute -> . return
    (106) empty -> .
    (37) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (42) assign -> . ID punto array ASSIGN express
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (49) cin -> . CIN LPAREN express RPAREN
    (50) cout -> . COUT LPAREN express cout1 RPAREN
    (53) delay -> . DELAY LPAREN express RPAREN
    (54) forward -> . FORWARD LPAREN express RPAREN
    (55) backward -> . BACKWARD LPAREN express RPAREN
    (56) turnleft -> . TURNLEFT LPAREN express RPAREN
    (57) turnright -> . TURNRIGHT LPAREN express RPAREN
    (58) servo -> . SERVO LPAREN express RPAREN
    (59) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (60) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (62) return -> . RETURN LPAREN express RPAREN
    (44) era -> . ID

    RCURLY          reduce using rule 106 (empty -> .)
    IF              shift and go to state 141
    ID              shift and go to state 142
    CIN             shift and go to state 143
    COUT            shift and go to state 144
    DELAY           shift and go to state 145
    FORWARD         shift and go to state 146
    BACKWARD        shift and go to state 147
    TURNLEFT        shift and go to state 148
    TURNRIGHT       shift and go to state 149
    SERVO           shift and go to state 150
    LIGHTS          shift and go to state 151
    WHILE           shift and go to state 152
    RETURN          shift and go to state 153

    block                          shift and go to state 218
    statute                        shift and go to state 125
    empty                          shift and go to state 126
    cond                           shift and go to state 127
    assign                         shift and go to state 128
    call                           shift and go to state 129
    cin                            shift and go to state 130
    cout                           shift and go to state 131
    delay                          shift and go to state 132
    forward                        shift and go to state 133
    backward                       shift and go to state 134
    turnleft                       shift and go to state 135
    turnright                      shift and go to state 136
    servo                          shift and go to state 137
    lights                         shift and go to state 138
    while                          shift and go to state 139
    return                         shift and go to state 140
    era                            shift and go to state 52

state 214

    (38) gotoif -> empty .

    IF              reduce using rule 38 (gotoif -> empty .)
    ID              reduce using rule 38 (gotoif -> empty .)
    CIN             reduce using rule 38 (gotoif -> empty .)
    COUT            reduce using rule 38 (gotoif -> empty .)
    DELAY           reduce using rule 38 (gotoif -> empty .)
    FORWARD         reduce using rule 38 (gotoif -> empty .)
    BACKWARD        reduce using rule 38 (gotoif -> empty .)
    TURNLEFT        reduce using rule 38 (gotoif -> empty .)
    TURNRIGHT       reduce using rule 38 (gotoif -> empty .)
    SERVO           reduce using rule 38 (gotoif -> empty .)
    LIGHTS          reduce using rule 38 (gotoif -> empty .)
    WHILE           reduce using rule 38 (gotoif -> empty .)
    RETURN          reduce using rule 38 (gotoif -> empty .)
    RCURLY          reduce using rule 38 (gotoif -> empty .)


state 215

    (51) cout1 -> COMMA express cout1 .

    RPAREN          reduce using rule 51 (cout1 -> COMMA express cout1 .)


state 216

    (59) lights -> LIGHTS LPAREN express COMMA express RPAREN .

    SEMICOLON       reduce using rule 59 (lights -> LIGHTS LPAREN express COMMA express RPAREN .)


state 217

    (60) while -> WHILE LPAREN express RPAREN while1 LCURLY . block RCURLY
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . while
    (36) statute -> . return
    (106) empty -> .
    (37) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (42) assign -> . ID punto array ASSIGN express
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (49) cin -> . CIN LPAREN express RPAREN
    (50) cout -> . COUT LPAREN express cout1 RPAREN
    (53) delay -> . DELAY LPAREN express RPAREN
    (54) forward -> . FORWARD LPAREN express RPAREN
    (55) backward -> . BACKWARD LPAREN express RPAREN
    (56) turnleft -> . TURNLEFT LPAREN express RPAREN
    (57) turnright -> . TURNRIGHT LPAREN express RPAREN
    (58) servo -> . SERVO LPAREN express RPAREN
    (59) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (60) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (62) return -> . RETURN LPAREN express RPAREN
    (44) era -> . ID

    RCURLY          reduce using rule 106 (empty -> .)
    IF              shift and go to state 141
    ID              shift and go to state 142
    CIN             shift and go to state 143
    COUT            shift and go to state 144
    DELAY           shift and go to state 145
    FORWARD         shift and go to state 146
    BACKWARD        shift and go to state 147
    TURNLEFT        shift and go to state 148
    TURNRIGHT       shift and go to state 149
    SERVO           shift and go to state 150
    LIGHTS          shift and go to state 151
    WHILE           shift and go to state 152
    RETURN          shift and go to state 153

    block                          shift and go to state 219
    statute                        shift and go to state 125
    empty                          shift and go to state 126
    cond                           shift and go to state 127
    assign                         shift and go to state 128
    call                           shift and go to state 129
    cin                            shift and go to state 130
    cout                           shift and go to state 131
    delay                          shift and go to state 132
    forward                        shift and go to state 133
    backward                       shift and go to state 134
    turnleft                       shift and go to state 135
    turnright                      shift and go to state 136
    servo                          shift and go to state 137
    lights                         shift and go to state 138
    while                          shift and go to state 139
    return                         shift and go to state 140
    era                            shift and go to state 52

state 218

    (37) cond -> IF LPAREN express RPAREN LCURLY gotoif block . RCURLY else

    RCURLY          shift and go to state 220


state 219

    (60) while -> WHILE LPAREN express RPAREN while1 LCURLY block . RCURLY

    RCURLY          shift and go to state 221


state 220

    (37) cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY . else
    (39) else -> . ELSE LCURLY gotoelse block RCURLY else
    (40) else -> . empty
    (106) empty -> .

    ELSE            shift and go to state 223
    SEMICOLON       reduce using rule 106 (empty -> .)

    else                           shift and go to state 222
    empty                          shift and go to state 224

state 221

    (60) while -> WHILE LPAREN express RPAREN while1 LCURLY block RCURLY .

    SEMICOLON       reduce using rule 60 (while -> WHILE LPAREN express RPAREN while1 LCURLY block RCURLY .)


state 222

    (37) cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY else .

    SEMICOLON       reduce using rule 37 (cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY else .)


state 223

    (39) else -> ELSE . LCURLY gotoelse block RCURLY else

    LCURLY          shift and go to state 225


state 224

    (40) else -> empty .

    SEMICOLON       reduce using rule 40 (else -> empty .)


state 225

    (39) else -> ELSE LCURLY . gotoelse block RCURLY else
    (41) gotoelse -> . empty
    (106) empty -> .

    IF              reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    CIN             reduce using rule 106 (empty -> .)
    COUT            reduce using rule 106 (empty -> .)
    DELAY           reduce using rule 106 (empty -> .)
    FORWARD         reduce using rule 106 (empty -> .)
    BACKWARD        reduce using rule 106 (empty -> .)
    TURNLEFT        reduce using rule 106 (empty -> .)
    TURNRIGHT       reduce using rule 106 (empty -> .)
    SERVO           reduce using rule 106 (empty -> .)
    LIGHTS          reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    RETURN          reduce using rule 106 (empty -> .)
    RCURLY          reduce using rule 106 (empty -> .)

    gotoelse                       shift and go to state 226
    empty                          shift and go to state 227

state 226

    (39) else -> ELSE LCURLY gotoelse . block RCURLY else
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . while
    (36) statute -> . return
    (106) empty -> .
    (37) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (42) assign -> . ID punto array ASSIGN express
    (43) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (49) cin -> . CIN LPAREN express RPAREN
    (50) cout -> . COUT LPAREN express cout1 RPAREN
    (53) delay -> . DELAY LPAREN express RPAREN
    (54) forward -> . FORWARD LPAREN express RPAREN
    (55) backward -> . BACKWARD LPAREN express RPAREN
    (56) turnleft -> . TURNLEFT LPAREN express RPAREN
    (57) turnright -> . TURNRIGHT LPAREN express RPAREN
    (58) servo -> . SERVO LPAREN express RPAREN
    (59) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (60) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (62) return -> . RETURN LPAREN express RPAREN
    (44) era -> . ID

    RCURLY          reduce using rule 106 (empty -> .)
    IF              shift and go to state 141
    ID              shift and go to state 142
    CIN             shift and go to state 143
    COUT            shift and go to state 144
    DELAY           shift and go to state 145
    FORWARD         shift and go to state 146
    BACKWARD        shift and go to state 147
    TURNLEFT        shift and go to state 148
    TURNRIGHT       shift and go to state 149
    SERVO           shift and go to state 150
    LIGHTS          shift and go to state 151
    WHILE           shift and go to state 152
    RETURN          shift and go to state 153

    block                          shift and go to state 228
    statute                        shift and go to state 125
    empty                          shift and go to state 126
    cond                           shift and go to state 127
    assign                         shift and go to state 128
    call                           shift and go to state 129
    cin                            shift and go to state 130
    cout                           shift and go to state 131
    delay                          shift and go to state 132
    forward                        shift and go to state 133
    backward                       shift and go to state 134
    turnleft                       shift and go to state 135
    turnright                      shift and go to state 136
    servo                          shift and go to state 137
    lights                         shift and go to state 138
    while                          shift and go to state 139
    return                         shift and go to state 140
    era                            shift and go to state 52

state 227

    (41) gotoelse -> empty .

    IF              reduce using rule 41 (gotoelse -> empty .)
    ID              reduce using rule 41 (gotoelse -> empty .)
    CIN             reduce using rule 41 (gotoelse -> empty .)
    COUT            reduce using rule 41 (gotoelse -> empty .)
    DELAY           reduce using rule 41 (gotoelse -> empty .)
    FORWARD         reduce using rule 41 (gotoelse -> empty .)
    BACKWARD        reduce using rule 41 (gotoelse -> empty .)
    TURNLEFT        reduce using rule 41 (gotoelse -> empty .)
    TURNRIGHT       reduce using rule 41 (gotoelse -> empty .)
    SERVO           reduce using rule 41 (gotoelse -> empty .)
    LIGHTS          reduce using rule 41 (gotoelse -> empty .)
    WHILE           reduce using rule 41 (gotoelse -> empty .)
    RETURN          reduce using rule 41 (gotoelse -> empty .)
    RCURLY          reduce using rule 41 (gotoelse -> empty .)


state 228

    (39) else -> ELSE LCURLY gotoelse block . RCURLY else

    RCURLY          shift and go to state 229


state 229

    (39) else -> ELSE LCURLY gotoelse block RCURLY . else
    (39) else -> . ELSE LCURLY gotoelse block RCURLY else
    (40) else -> . empty
    (106) empty -> .

    ELSE            shift and go to state 223
    SEMICOLON       reduce using rule 106 (empty -> .)

    else                           shift and go to state 230
    empty                          shift and go to state 224

state 230

    (39) else -> ELSE LCURLY gotoelse block RCURLY else .

    SEMICOLON       reduce using rule 39 (else -> ELSE LCURLY gotoelse block RCURLY else .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 35 resolved as shift
WARNING: shift/reduce conflict for INT in state 35 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 35 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 35 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 35 resolved as shift
WARNING: shift/reduce conflict for VOID in state 35 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 57 resolved as shift
WARNING: shift/reduce conflict for INT in state 57 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 57 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 57 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 57 resolved as shift
WARNING: shift/reduce conflict for VOID in state 57 resolved as shift
WARNING: shift/reduce conflict for INT in state 58 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 58 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 58 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 58 resolved as shift
WARNING: shift/reduce conflict for VOID in state 58 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 93 resolved as shift
WARNING: shift/reduce conflict for INT in state 93 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 93 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 93 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 93 resolved as shift
WARNING: shift/reduce conflict for VOID in state 93 resolved as shift
WARNING: reduce/reduce conflict in state 59 resolved using rule (paramsblock -> empty)
WARNING: rejected rule (params -> empty) in state 59
