Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CTE_ARR

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON
Rule 2     gotomain -> empty
Rule 3     main -> MAIN setmain LPAREN RPAREN LCURLY varsblock block RCURLY
Rule 4     setmain -> empty
Rule 5     funcsblock -> funcs funcsblock
Rule 6     funcsblock -> empty
Rule 7     funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
Rule 8     funcs1 -> empty
Rule 9     setscope -> ID
Rule 10    varsblock -> vars varsblock
Rule 11    varsblock -> empty
Rule 12    vars -> VARDEF type ID vars1 SEMICOLON
Rule 13    vars1 -> LBRACKET CTE_INT RBRACKET
Rule 14    vars1 -> empty
Rule 15    paramsblock -> params paramsblock
Rule 16    paramsblock -> COMMA params paramsblock
Rule 17    paramsblock -> empty
Rule 18    params -> type ID
Rule 19    params -> empty
Rule 20    block -> statute SEMICOLON block
Rule 21    block -> empty
Rule 22    statute -> cond
Rule 23    statute -> assign
Rule 24    statute -> call
Rule 25    statute -> cin
Rule 26    statute -> cout
Rule 27    statute -> delay
Rule 28    statute -> forward
Rule 29    statute -> backward
Rule 30    statute -> turnleft
Rule 31    statute -> turnright
Rule 32    statute -> servo
Rule 33    statute -> lights
Rule 34    statute -> display
Rule 35    statute -> distance
Rule 36    statute -> stop
Rule 37    statute -> while
Rule 38    statute -> return
Rule 39    cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
Rule 40    gotoif -> empty
Rule 41    else -> ELSE LCURLY gotoelse block RCURLY else
Rule 42    else -> empty
Rule 43    gotoelse -> empty
Rule 44    assign -> ID assign1 ASSIGN express
Rule 45    assign1 -> LBRACKET express RBRACKET
Rule 46    assign1 -> empty
Rule 47    call -> era LPAREN paramcall RPAREN
Rule 48    era -> ID
Rule 49    paramcall -> express paramcall1
Rule 50    paramcall1 -> COMMA paramcall
Rule 51    paramcall1 -> empty
Rule 52    cin -> CIN cin1
Rule 53    cin1 -> cin2
Rule 54    cin1 -> cin3
Rule 55    cin2 -> LPAREN ID RPAREN
Rule 56    cin3 -> LBRACKET CTE_INT RBRACKET LPAREN cin4 RPAREN
Rule 57    cin4 -> COMMA ID cin4
Rule 58    cin4 -> empty
Rule 59    cout -> COUT LPAREN express cout1 RPAREN
Rule 60    cout1 -> COMMA express cout1
Rule 61    cout1 -> empty
Rule 62    delay -> DELAY LPAREN express RPAREN
Rule 63    forward -> FORWARD LPAREN express COMMA express RPAREN
Rule 64    backward -> BACKWARD LPAREN express COMMA express RPAREN
Rule 65    turnleft -> TURNLEFT LPAREN express COMMA express RPAREN
Rule 66    turnright -> TURNRIGHT LPAREN express COMMA express RPAREN
Rule 67    servo -> SERVO LPAREN express RPAREN
Rule 68    lights -> LIGHTS LPAREN express COMMA express RPAREN
Rule 69    display -> DISPLAY LPAREN express RPAREN
Rule 70    distance -> DISTANCE LPAREN RPAREN
Rule 71    stop -> STOP LPAREN RPAREN
Rule 72    while -> WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
Rule 73    while1 -> empty
Rule 74    return -> RETURN LPAREN express RPAREN
Rule 75    type -> INT
Rule 76    type -> FLOAT
Rule 77    type -> BOOL
Rule 78    type -> CHAR
Rule 79    type -> VOID
Rule 80    constant -> ID
Rule 81    constant -> CTE_INT
Rule 82    constant -> CTE_FLOAT
Rule 83    constant -> CTE_CHAR
Rule 84    constant -> CTE_BOOL
Rule 85    express -> express1 relational express2
Rule 86    express1 -> NOTEQUALS
Rule 87    express1 -> empty
Rule 88    express2 -> andor express
Rule 89    express2 -> empty
Rule 90    andor -> AND
Rule 91    andor -> OR
Rule 92    relational -> exp relational1
Rule 93    relational -> NOT
Rule 94    relational1 -> compare exp
Rule 95    relational1 -> empty
Rule 96    compare -> LESSTHAN
Rule 97    compare -> GREATERTHAN
Rule 98    compare -> EQUALS
Rule 99    compare -> NOTEQUALS
Rule 100   exp -> term exp1
Rule 101   exp1 -> plusminus exp
Rule 102   exp1 -> empty
Rule 103   plusminus -> PLUS
Rule 104   plusminus -> MINUS
Rule 105   term -> factor term1
Rule 106   term1 -> multidivi term
Rule 107   term1 -> empty
Rule 108   multidivi -> MULTI
Rule 109   multidivi -> DIVI
Rule 110   factor -> LPAREN express RPAREN
Rule 111   factor -> constant
Rule 112   factor -> call
Rule 113   empty -> <empty>

Terminals, with rules where they appear

AND                  : 90
ASSIGN               : 44
BACKWARD             : 64
BOOL                 : 77
CHAR                 : 78
CIN                  : 52
COMMA                : 16 50 57 60 63 64 65 66 68
COUT                 : 59
CTE_ARR              : 
CTE_BOOL             : 84
CTE_CHAR             : 83
CTE_FLOAT            : 82
CTE_INT              : 13 56 81
DELAY                : 62
DISPLAY              : 69
DISTANCE             : 70
DIVI                 : 109
ELSE                 : 41
EQUALS               : 98
FIN                  : 1
FLOAT                : 76
FORWARD              : 63
FUNCDEF              : 7
GREATERTHAN          : 97
ID                   : 9 12 18 44 48 55 57 80
IF                   : 39
INT                  : 75
LBRACKET             : 13 45 56
LCURLY               : 3 7 39 41 72
LESSTHAN             : 96
LIGHTS               : 68
LPAREN               : 3 7 39 47 55 56 59 62 63 64 65 66 67 68 69 70 71 72 74 110
MAIN                 : 3
MINUS                : 104
MULTI                : 108
NOT                  : 93
NOTEQUALS            : 86 99
OR                   : 91
PLUS                 : 103
PROGRAM              : 1
RBRACKET             : 13 45 56
RCURLY               : 3 7 39 41 72
RETURN               : 74
RPAREN               : 3 7 39 47 55 56 59 62 63 64 65 66 67 68 69 70 71 72 74 110
SEMICOLON            : 1 12 20
SERVO                : 67
STOP                 : 71
TURNLEFT             : 65
TURNRIGHT            : 66
VARDEF               : 12
VOID                 : 79
WHILE                : 72
error                : 

Nonterminals, with rules where they appear

andor                : 88
assign               : 23
assign1              : 44
backward             : 29
block                : 3 7 20 39 41 72
call                 : 24 112
cin                  : 25
cin1                 : 52
cin2                 : 53
cin3                 : 54
cin4                 : 56 57
compare              : 94
cond                 : 22
constant             : 111
cout                 : 26
cout1                : 59 60
delay                : 27
display              : 34
distance             : 35
else                 : 39 41
empty                : 2 4 6 8 11 14 17 19 21 40 42 43 46 51 58 61 73 87 89 95 102 107
era                  : 47
exp                  : 92 94 101
exp1                 : 100
express              : 39 44 45 49 59 60 62 63 63 64 64 65 65 66 66 67 68 68 69 72 74 88 110
express1             : 85
express2             : 85
factor               : 105
forward              : 28
funcs                : 5
funcs1               : 7
funcsblock           : 1 5
gotoelse             : 41
gotoif               : 39
gotomain             : 1
lights               : 33
main                 : 1
multidivi            : 106
paramcall            : 47 50
paramcall1           : 49
params               : 15 16
paramsblock          : 7 15 16
plusminus            : 101
program              : 0
relational           : 85
relational1          : 92
return               : 38
servo                : 32
setmain              : 3
setscope             : 7
statute              : 20
stop                 : 36
term                 : 100 106
term1                : 105
turnleft             : 30
turnright            : 31
type                 : 7 12 18
vars                 : 10
vars1                : 12
varsblock            : 1 3 7 10
while                : 37
while1               : 72

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . gotomain varsblock funcsblock main FIN SEMICOLON
    (2) gotomain -> . empty
    (113) empty -> .

    VARDEF          reduce using rule 113 (empty -> .)
    FUNCDEF         reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)

    gotomain                       shift and go to state 3
    empty                          shift and go to state 4

state 3

    (1) program -> PROGRAM gotomain . varsblock funcsblock main FIN SEMICOLON
    (10) varsblock -> . vars varsblock
    (11) varsblock -> . empty
    (12) vars -> . VARDEF type ID vars1 SEMICOLON
    (113) empty -> .

    VARDEF          shift and go to state 8
    FUNCDEF         reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)

    varsblock                      shift and go to state 5
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 4

    (2) gotomain -> empty .

    VARDEF          reduce using rule 2 (gotomain -> empty .)
    FUNCDEF         reduce using rule 2 (gotomain -> empty .)
    MAIN            reduce using rule 2 (gotomain -> empty .)


state 5

    (1) program -> PROGRAM gotomain varsblock . funcsblock main FIN SEMICOLON
    (5) funcsblock -> . funcs funcsblock
    (6) funcsblock -> . empty
    (7) funcs -> . FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (113) empty -> .

    FUNCDEF         shift and go to state 12
    MAIN            reduce using rule 113 (empty -> .)

    funcsblock                     shift and go to state 9
    funcs                          shift and go to state 10
    empty                          shift and go to state 11

state 6

    (10) varsblock -> vars . varsblock
    (10) varsblock -> . vars varsblock
    (11) varsblock -> . empty
    (12) vars -> . VARDEF type ID vars1 SEMICOLON
    (113) empty -> .

    VARDEF          shift and go to state 8
    FUNCDEF         reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISPLAY         reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    vars                           shift and go to state 6
    varsblock                      shift and go to state 13
    empty                          shift and go to state 7

state 7

    (11) varsblock -> empty .

    FUNCDEF         reduce using rule 11 (varsblock -> empty .)
    MAIN            reduce using rule 11 (varsblock -> empty .)
    IF              reduce using rule 11 (varsblock -> empty .)
    ID              reduce using rule 11 (varsblock -> empty .)
    CIN             reduce using rule 11 (varsblock -> empty .)
    COUT            reduce using rule 11 (varsblock -> empty .)
    DELAY           reduce using rule 11 (varsblock -> empty .)
    FORWARD         reduce using rule 11 (varsblock -> empty .)
    BACKWARD        reduce using rule 11 (varsblock -> empty .)
    TURNLEFT        reduce using rule 11 (varsblock -> empty .)
    TURNRIGHT       reduce using rule 11 (varsblock -> empty .)
    SERVO           reduce using rule 11 (varsblock -> empty .)
    LIGHTS          reduce using rule 11 (varsblock -> empty .)
    DISPLAY         reduce using rule 11 (varsblock -> empty .)
    DISTANCE        reduce using rule 11 (varsblock -> empty .)
    STOP            reduce using rule 11 (varsblock -> empty .)
    WHILE           reduce using rule 11 (varsblock -> empty .)
    RETURN          reduce using rule 11 (varsblock -> empty .)
    RCURLY          reduce using rule 11 (varsblock -> empty .)


state 8

    (12) vars -> VARDEF . type ID vars1 SEMICOLON
    (75) type -> . INT
    (76) type -> . FLOAT
    (77) type -> . BOOL
    (78) type -> . CHAR
    (79) type -> . VOID

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

    type                           shift and go to state 14

state 9

    (1) program -> PROGRAM gotomain varsblock funcsblock . main FIN SEMICOLON
    (3) main -> . MAIN setmain LPAREN RPAREN LCURLY varsblock block RCURLY

    MAIN            shift and go to state 21

    main                           shift and go to state 20

state 10

    (5) funcsblock -> funcs . funcsblock
    (5) funcsblock -> . funcs funcsblock
    (6) funcsblock -> . empty
    (7) funcs -> . FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (113) empty -> .

    FUNCDEF         shift and go to state 12
    MAIN            reduce using rule 113 (empty -> .)

    funcs                          shift and go to state 10
    funcsblock                     shift and go to state 22
    empty                          shift and go to state 11

state 11

    (6) funcsblock -> empty .

    MAIN            reduce using rule 6 (funcsblock -> empty .)


state 12

    (7) funcs -> FUNCDEF . type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (75) type -> . INT
    (76) type -> . FLOAT
    (77) type -> . BOOL
    (78) type -> . CHAR
    (79) type -> . VOID

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

    type                           shift and go to state 23

state 13

    (10) varsblock -> vars varsblock .

    FUNCDEF         reduce using rule 10 (varsblock -> vars varsblock .)
    MAIN            reduce using rule 10 (varsblock -> vars varsblock .)
    IF              reduce using rule 10 (varsblock -> vars varsblock .)
    ID              reduce using rule 10 (varsblock -> vars varsblock .)
    CIN             reduce using rule 10 (varsblock -> vars varsblock .)
    COUT            reduce using rule 10 (varsblock -> vars varsblock .)
    DELAY           reduce using rule 10 (varsblock -> vars varsblock .)
    FORWARD         reduce using rule 10 (varsblock -> vars varsblock .)
    BACKWARD        reduce using rule 10 (varsblock -> vars varsblock .)
    TURNLEFT        reduce using rule 10 (varsblock -> vars varsblock .)
    TURNRIGHT       reduce using rule 10 (varsblock -> vars varsblock .)
    SERVO           reduce using rule 10 (varsblock -> vars varsblock .)
    LIGHTS          reduce using rule 10 (varsblock -> vars varsblock .)
    DISPLAY         reduce using rule 10 (varsblock -> vars varsblock .)
    DISTANCE        reduce using rule 10 (varsblock -> vars varsblock .)
    STOP            reduce using rule 10 (varsblock -> vars varsblock .)
    WHILE           reduce using rule 10 (varsblock -> vars varsblock .)
    RETURN          reduce using rule 10 (varsblock -> vars varsblock .)
    RCURLY          reduce using rule 10 (varsblock -> vars varsblock .)


state 14

    (12) vars -> VARDEF type . ID vars1 SEMICOLON

    ID              shift and go to state 24


state 15

    (75) type -> INT .

    ID              reduce using rule 75 (type -> INT .)


state 16

    (76) type -> FLOAT .

    ID              reduce using rule 76 (type -> FLOAT .)


state 17

    (77) type -> BOOL .

    ID              reduce using rule 77 (type -> BOOL .)


state 18

    (78) type -> CHAR .

    ID              reduce using rule 78 (type -> CHAR .)


state 19

    (79) type -> VOID .

    ID              reduce using rule 79 (type -> VOID .)


state 20

    (1) program -> PROGRAM gotomain varsblock funcsblock main . FIN SEMICOLON

    FIN             shift and go to state 25


state 21

    (3) main -> MAIN . setmain LPAREN RPAREN LCURLY varsblock block RCURLY
    (4) setmain -> . empty
    (113) empty -> .

    LPAREN          reduce using rule 113 (empty -> .)

    setmain                        shift and go to state 26
    empty                          shift and go to state 27

state 22

    (5) funcsblock -> funcs funcsblock .

    MAIN            reduce using rule 5 (funcsblock -> funcs funcsblock .)


state 23

    (7) funcs -> FUNCDEF type . setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (9) setscope -> . ID

    ID              shift and go to state 29

    setscope                       shift and go to state 28

state 24

    (12) vars -> VARDEF type ID . vars1 SEMICOLON
    (13) vars1 -> . LBRACKET CTE_INT RBRACKET
    (14) vars1 -> . empty
    (113) empty -> .

    LBRACKET        shift and go to state 31
    SEMICOLON       reduce using rule 113 (empty -> .)

    vars1                          shift and go to state 30
    empty                          shift and go to state 32

state 25

    (1) program -> PROGRAM gotomain varsblock funcsblock main FIN . SEMICOLON

    SEMICOLON       shift and go to state 33


state 26

    (3) main -> MAIN setmain . LPAREN RPAREN LCURLY varsblock block RCURLY

    LPAREN          shift and go to state 34


state 27

    (4) setmain -> empty .

    LPAREN          reduce using rule 4 (setmain -> empty .)


state 28

    (7) funcs -> FUNCDEF type setscope . LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY

    LPAREN          shift and go to state 35


state 29

    (9) setscope -> ID .

    LPAREN          reduce using rule 9 (setscope -> ID .)


state 30

    (12) vars -> VARDEF type ID vars1 . SEMICOLON

    SEMICOLON       shift and go to state 36


state 31

    (13) vars1 -> LBRACKET . CTE_INT RBRACKET

    CTE_INT         shift and go to state 37


state 32

    (14) vars1 -> empty .

    SEMICOLON       reduce using rule 14 (vars1 -> empty .)


state 33

    (1) program -> PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON .

    $end            reduce using rule 1 (program -> PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON .)


state 34

    (3) main -> MAIN setmain LPAREN . RPAREN LCURLY varsblock block RCURLY

    RPAREN          shift and go to state 38


state 35

    (7) funcs -> FUNCDEF type setscope LPAREN . paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (15) paramsblock -> . params paramsblock
    (16) paramsblock -> . COMMA params paramsblock
    (17) paramsblock -> . empty
    (18) params -> . type ID
    (19) params -> . empty
    (113) empty -> .
    (75) type -> . INT
    (76) type -> . FLOAT
    (77) type -> . BOOL
    (78) type -> . CHAR
    (79) type -> . VOID

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMA           shift and go to state 42
    RPAREN          reduce using rule 113 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

  ! COMMA           [ reduce using rule 113 (empty -> .) ]
  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! VOID            [ reduce using rule 113 (empty -> .) ]

    type                           shift and go to state 39
    paramsblock                    shift and go to state 40
    params                         shift and go to state 41
    empty                          shift and go to state 43

state 36

    (12) vars -> VARDEF type ID vars1 SEMICOLON .

    VARDEF          reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    FUNCDEF         reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    MAIN            reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    IF              reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    ID              reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    CIN             reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    COUT            reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    DELAY           reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    FORWARD         reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    BACKWARD        reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    TURNLEFT        reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    TURNRIGHT       reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    SERVO           reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    LIGHTS          reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    DISPLAY         reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    DISTANCE        reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    STOP            reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    WHILE           reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    RETURN          reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)
    RCURLY          reduce using rule 12 (vars -> VARDEF type ID vars1 SEMICOLON .)


state 37

    (13) vars1 -> LBRACKET CTE_INT . RBRACKET

    RBRACKET        shift and go to state 44


state 38

    (3) main -> MAIN setmain LPAREN RPAREN . LCURLY varsblock block RCURLY

    LCURLY          shift and go to state 45


state 39

    (18) params -> type . ID

    ID              shift and go to state 46


state 40

    (7) funcs -> FUNCDEF type setscope LPAREN paramsblock . RPAREN LCURLY varsblock funcs1 block RCURLY

    RPAREN          shift and go to state 47


state 41

    (15) paramsblock -> params . paramsblock
    (15) paramsblock -> . params paramsblock
    (16) paramsblock -> . COMMA params paramsblock
    (17) paramsblock -> . empty
    (18) params -> . type ID
    (19) params -> . empty
    (113) empty -> .
    (75) type -> . INT
    (76) type -> . FLOAT
    (77) type -> . BOOL
    (78) type -> . CHAR
    (79) type -> . VOID

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMA           shift and go to state 42
    RPAREN          reduce using rule 113 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

  ! COMMA           [ reduce using rule 113 (empty -> .) ]
  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! VOID            [ reduce using rule 113 (empty -> .) ]

    params                         shift and go to state 41
    paramsblock                    shift and go to state 48
    empty                          shift and go to state 43
    type                           shift and go to state 39

state 42

    (16) paramsblock -> COMMA . params paramsblock
    (18) params -> . type ID
    (19) params -> . empty
    (75) type -> . INT
    (76) type -> . FLOAT
    (77) type -> . BOOL
    (78) type -> . CHAR
    (79) type -> . VOID
    (113) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19
    COMMA           reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! VOID            [ reduce using rule 113 (empty -> .) ]

    params                         shift and go to state 49
    type                           shift and go to state 39
    empty                          shift and go to state 50

state 43

    (17) paramsblock -> empty .
    (19) params -> empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 17 (paramsblock -> empty .)
    RPAREN          reduce using rule 17 (paramsblock -> empty .)
    COMMA           reduce using rule 19 (params -> empty .)
    INT             reduce using rule 19 (params -> empty .)
    FLOAT           reduce using rule 19 (params -> empty .)
    BOOL            reduce using rule 19 (params -> empty .)
    CHAR            reduce using rule 19 (params -> empty .)
    VOID            reduce using rule 19 (params -> empty .)

  ! RPAREN          [ reduce using rule 19 (params -> empty .) ]


state 44

    (13) vars1 -> LBRACKET CTE_INT RBRACKET .

    SEMICOLON       reduce using rule 13 (vars1 -> LBRACKET CTE_INT RBRACKET .)


state 45

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY . varsblock block RCURLY
    (10) varsblock -> . vars varsblock
    (11) varsblock -> . empty
    (12) vars -> . VARDEF type ID vars1 SEMICOLON
    (113) empty -> .

    VARDEF          shift and go to state 8
    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISPLAY         reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    varsblock                      shift and go to state 51
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 46

    (18) params -> type ID .

    COMMA           reduce using rule 18 (params -> type ID .)
    INT             reduce using rule 18 (params -> type ID .)
    FLOAT           reduce using rule 18 (params -> type ID .)
    BOOL            reduce using rule 18 (params -> type ID .)
    CHAR            reduce using rule 18 (params -> type ID .)
    VOID            reduce using rule 18 (params -> type ID .)
    RPAREN          reduce using rule 18 (params -> type ID .)


state 47

    (7) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN . LCURLY varsblock funcs1 block RCURLY

    LCURLY          shift and go to state 52


state 48

    (15) paramsblock -> params paramsblock .

    RPAREN          reduce using rule 15 (paramsblock -> params paramsblock .)


state 49

    (16) paramsblock -> COMMA params . paramsblock
    (15) paramsblock -> . params paramsblock
    (16) paramsblock -> . COMMA params paramsblock
    (17) paramsblock -> . empty
    (18) params -> . type ID
    (19) params -> . empty
    (113) empty -> .
    (75) type -> . INT
    (76) type -> . FLOAT
    (77) type -> . BOOL
    (78) type -> . CHAR
    (79) type -> . VOID

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMA           shift and go to state 42
    RPAREN          reduce using rule 113 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

  ! COMMA           [ reduce using rule 113 (empty -> .) ]
  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! VOID            [ reduce using rule 113 (empty -> .) ]

    params                         shift and go to state 41
    paramsblock                    shift and go to state 53
    empty                          shift and go to state 43
    type                           shift and go to state 39

state 50

    (19) params -> empty .

    COMMA           reduce using rule 19 (params -> empty .)
    INT             reduce using rule 19 (params -> empty .)
    FLOAT           reduce using rule 19 (params -> empty .)
    BOOL            reduce using rule 19 (params -> empty .)
    CHAR            reduce using rule 19 (params -> empty .)
    VOID            reduce using rule 19 (params -> empty .)
    RPAREN          reduce using rule 19 (params -> empty .)


state 51

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock . block RCURLY
    (20) block -> . statute SEMICOLON block
    (21) block -> . empty
    (22) statute -> . cond
    (23) statute -> . assign
    (24) statute -> . call
    (25) statute -> . cin
    (26) statute -> . cout
    (27) statute -> . delay
    (28) statute -> . forward
    (29) statute -> . backward
    (30) statute -> . turnleft
    (31) statute -> . turnright
    (32) statute -> . servo
    (33) statute -> . lights
    (34) statute -> . display
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID assign1 ASSIGN express
    (47) call -> . era LPAREN paramcall RPAREN
    (52) cin -> . CIN cin1
    (59) cout -> . COUT LPAREN express cout1 RPAREN
    (62) delay -> . DELAY LPAREN express RPAREN
    (63) forward -> . FORWARD LPAREN express COMMA express RPAREN
    (64) backward -> . BACKWARD LPAREN express COMMA express RPAREN
    (65) turnleft -> . TURNLEFT LPAREN express COMMA express RPAREN
    (66) turnright -> . TURNRIGHT LPAREN express COMMA express RPAREN
    (67) servo -> . SERVO LPAREN express RPAREN
    (68) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (69) display -> . DISPLAY LPAREN express RPAREN
    (70) distance -> . DISTANCE LPAREN RPAREN
    (71) stop -> . STOP LPAREN RPAREN
    (72) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (74) return -> . RETURN LPAREN express RPAREN
    (48) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 74
    ID              shift and go to state 75
    CIN             shift and go to state 77
    COUT            shift and go to state 78
    DELAY           shift and go to state 79
    FORWARD         shift and go to state 80
    BACKWARD        shift and go to state 81
    TURNLEFT        shift and go to state 82
    TURNRIGHT       shift and go to state 83
    SERVO           shift and go to state 84
    LIGHTS          shift and go to state 85
    DISPLAY         shift and go to state 86
    DISTANCE        shift and go to state 87
    STOP            shift and go to state 88
    WHILE           shift and go to state 89
    RETURN          shift and go to state 90

    block                          shift and go to state 54
    statute                        shift and go to state 55
    empty                          shift and go to state 56
    cond                           shift and go to state 57
    assign                         shift and go to state 58
    call                           shift and go to state 59
    cin                            shift and go to state 60
    cout                           shift and go to state 61
    delay                          shift and go to state 62
    forward                        shift and go to state 63
    backward                       shift and go to state 64
    turnleft                       shift and go to state 65
    turnright                      shift and go to state 66
    servo                          shift and go to state 67
    lights                         shift and go to state 68
    display                        shift and go to state 69
    distance                       shift and go to state 70
    stop                           shift and go to state 71
    while                          shift and go to state 72
    return                         shift and go to state 73
    era                            shift and go to state 76

state 52

    (7) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY . varsblock funcs1 block RCURLY
    (10) varsblock -> . vars varsblock
    (11) varsblock -> . empty
    (12) vars -> . VARDEF type ID vars1 SEMICOLON
    (113) empty -> .

    VARDEF          shift and go to state 8
    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISPLAY         reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    varsblock                      shift and go to state 91
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 53

    (16) paramsblock -> COMMA params paramsblock .

    RPAREN          reduce using rule 16 (paramsblock -> COMMA params paramsblock .)


state 54

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock block . RCURLY

    RCURLY          shift and go to state 92


state 55

    (20) block -> statute . SEMICOLON block

    SEMICOLON       shift and go to state 93


state 56

    (21) block -> empty .

    RCURLY          reduce using rule 21 (block -> empty .)


state 57

    (22) statute -> cond .

    SEMICOLON       reduce using rule 22 (statute -> cond .)


state 58

    (23) statute -> assign .

    SEMICOLON       reduce using rule 23 (statute -> assign .)


state 59

    (24) statute -> call .

    SEMICOLON       reduce using rule 24 (statute -> call .)


state 60

    (25) statute -> cin .

    SEMICOLON       reduce using rule 25 (statute -> cin .)


state 61

    (26) statute -> cout .

    SEMICOLON       reduce using rule 26 (statute -> cout .)


state 62

    (27) statute -> delay .

    SEMICOLON       reduce using rule 27 (statute -> delay .)


state 63

    (28) statute -> forward .

    SEMICOLON       reduce using rule 28 (statute -> forward .)


state 64

    (29) statute -> backward .

    SEMICOLON       reduce using rule 29 (statute -> backward .)


state 65

    (30) statute -> turnleft .

    SEMICOLON       reduce using rule 30 (statute -> turnleft .)


state 66

    (31) statute -> turnright .

    SEMICOLON       reduce using rule 31 (statute -> turnright .)


state 67

    (32) statute -> servo .

    SEMICOLON       reduce using rule 32 (statute -> servo .)


state 68

    (33) statute -> lights .

    SEMICOLON       reduce using rule 33 (statute -> lights .)


state 69

    (34) statute -> display .

    SEMICOLON       reduce using rule 34 (statute -> display .)


state 70

    (35) statute -> distance .

    SEMICOLON       reduce using rule 35 (statute -> distance .)


state 71

    (36) statute -> stop .

    SEMICOLON       reduce using rule 36 (statute -> stop .)


state 72

    (37) statute -> while .

    SEMICOLON       reduce using rule 37 (statute -> while .)


state 73

    (38) statute -> return .

    SEMICOLON       reduce using rule 38 (statute -> return .)


state 74

    (39) cond -> IF . LPAREN express RPAREN LCURLY gotoif block RCURLY else

    LPAREN          shift and go to state 94


state 75

    (44) assign -> ID . assign1 ASSIGN express
    (48) era -> ID .
    (45) assign1 -> . LBRACKET express RBRACKET
    (46) assign1 -> . empty
    (113) empty -> .

    LPAREN          reduce using rule 48 (era -> ID .)
    LBRACKET        shift and go to state 96
    ASSIGN          reduce using rule 113 (empty -> .)

    assign1                        shift and go to state 95
    empty                          shift and go to state 97

state 76

    (47) call -> era . LPAREN paramcall RPAREN

    LPAREN          shift and go to state 98


state 77

    (52) cin -> CIN . cin1
    (53) cin1 -> . cin2
    (54) cin1 -> . cin3
    (55) cin2 -> . LPAREN ID RPAREN
    (56) cin3 -> . LBRACKET CTE_INT RBRACKET LPAREN cin4 RPAREN

    LPAREN          shift and go to state 102
    LBRACKET        shift and go to state 103

    cin1                           shift and go to state 99
    cin2                           shift and go to state 100
    cin3                           shift and go to state 101

state 78

    (59) cout -> COUT . LPAREN express cout1 RPAREN

    LPAREN          shift and go to state 104


state 79

    (62) delay -> DELAY . LPAREN express RPAREN

    LPAREN          shift and go to state 105


state 80

    (63) forward -> FORWARD . LPAREN express COMMA express RPAREN

    LPAREN          shift and go to state 106


state 81

    (64) backward -> BACKWARD . LPAREN express COMMA express RPAREN

    LPAREN          shift and go to state 107


state 82

    (65) turnleft -> TURNLEFT . LPAREN express COMMA express RPAREN

    LPAREN          shift and go to state 108


state 83

    (66) turnright -> TURNRIGHT . LPAREN express COMMA express RPAREN

    LPAREN          shift and go to state 109


state 84

    (67) servo -> SERVO . LPAREN express RPAREN

    LPAREN          shift and go to state 110


state 85

    (68) lights -> LIGHTS . LPAREN express COMMA express RPAREN

    LPAREN          shift and go to state 111


state 86

    (69) display -> DISPLAY . LPAREN express RPAREN

    LPAREN          shift and go to state 112


state 87

    (70) distance -> DISTANCE . LPAREN RPAREN

    LPAREN          shift and go to state 113


state 88

    (71) stop -> STOP . LPAREN RPAREN

    LPAREN          shift and go to state 114


state 89

    (72) while -> WHILE . LPAREN express RPAREN while1 LCURLY block RCURLY

    LPAREN          shift and go to state 115


state 90

    (74) return -> RETURN . LPAREN express RPAREN

    LPAREN          shift and go to state 116


state 91

    (7) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock . funcs1 block RCURLY
    (8) funcs1 -> . empty
    (113) empty -> .

    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISPLAY         reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    funcs1                         shift and go to state 117
    empty                          shift and go to state 118

state 92

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock block RCURLY .

    FIN             reduce using rule 3 (main -> MAIN setmain LPAREN RPAREN LCURLY varsblock block RCURLY .)


state 93

    (20) block -> statute SEMICOLON . block
    (20) block -> . statute SEMICOLON block
    (21) block -> . empty
    (22) statute -> . cond
    (23) statute -> . assign
    (24) statute -> . call
    (25) statute -> . cin
    (26) statute -> . cout
    (27) statute -> . delay
    (28) statute -> . forward
    (29) statute -> . backward
    (30) statute -> . turnleft
    (31) statute -> . turnright
    (32) statute -> . servo
    (33) statute -> . lights
    (34) statute -> . display
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID assign1 ASSIGN express
    (47) call -> . era LPAREN paramcall RPAREN
    (52) cin -> . CIN cin1
    (59) cout -> . COUT LPAREN express cout1 RPAREN
    (62) delay -> . DELAY LPAREN express RPAREN
    (63) forward -> . FORWARD LPAREN express COMMA express RPAREN
    (64) backward -> . BACKWARD LPAREN express COMMA express RPAREN
    (65) turnleft -> . TURNLEFT LPAREN express COMMA express RPAREN
    (66) turnright -> . TURNRIGHT LPAREN express COMMA express RPAREN
    (67) servo -> . SERVO LPAREN express RPAREN
    (68) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (69) display -> . DISPLAY LPAREN express RPAREN
    (70) distance -> . DISTANCE LPAREN RPAREN
    (71) stop -> . STOP LPAREN RPAREN
    (72) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (74) return -> . RETURN LPAREN express RPAREN
    (48) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 74
    ID              shift and go to state 75
    CIN             shift and go to state 77
    COUT            shift and go to state 78
    DELAY           shift and go to state 79
    FORWARD         shift and go to state 80
    BACKWARD        shift and go to state 81
    TURNLEFT        shift and go to state 82
    TURNRIGHT       shift and go to state 83
    SERVO           shift and go to state 84
    LIGHTS          shift and go to state 85
    DISPLAY         shift and go to state 86
    DISTANCE        shift and go to state 87
    STOP            shift and go to state 88
    WHILE           shift and go to state 89
    RETURN          shift and go to state 90

    statute                        shift and go to state 55
    block                          shift and go to state 119
    empty                          shift and go to state 56
    cond                           shift and go to state 57
    assign                         shift and go to state 58
    call                           shift and go to state 59
    cin                            shift and go to state 60
    cout                           shift and go to state 61
    delay                          shift and go to state 62
    forward                        shift and go to state 63
    backward                       shift and go to state 64
    turnleft                       shift and go to state 65
    turnright                      shift and go to state 66
    servo                          shift and go to state 67
    lights                         shift and go to state 68
    display                        shift and go to state 69
    distance                       shift and go to state 70
    stop                           shift and go to state 71
    while                          shift and go to state 72
    return                         shift and go to state 73
    era                            shift and go to state 76

state 94

    (39) cond -> IF LPAREN . express RPAREN LCURLY gotoif block RCURLY else
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 120
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 95

    (44) assign -> ID assign1 . ASSIGN express

    ASSIGN          shift and go to state 124


state 96

    (45) assign1 -> LBRACKET . express RBRACKET
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 125
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 97

    (46) assign1 -> empty .

    ASSIGN          reduce using rule 46 (assign1 -> empty .)


state 98

    (47) call -> era LPAREN . paramcall RPAREN
    (49) paramcall -> . express paramcall1
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    paramcall                      shift and go to state 126
    express                        shift and go to state 127
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 99

    (52) cin -> CIN cin1 .

    SEMICOLON       reduce using rule 52 (cin -> CIN cin1 .)


state 100

    (53) cin1 -> cin2 .

    SEMICOLON       reduce using rule 53 (cin1 -> cin2 .)


state 101

    (54) cin1 -> cin3 .

    SEMICOLON       reduce using rule 54 (cin1 -> cin3 .)


state 102

    (55) cin2 -> LPAREN . ID RPAREN

    ID              shift and go to state 128


state 103

    (56) cin3 -> LBRACKET . CTE_INT RBRACKET LPAREN cin4 RPAREN

    CTE_INT         shift and go to state 129


state 104

    (59) cout -> COUT LPAREN . express cout1 RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 130
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 105

    (62) delay -> DELAY LPAREN . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 131
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 106

    (63) forward -> FORWARD LPAREN . express COMMA express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 132
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 107

    (64) backward -> BACKWARD LPAREN . express COMMA express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 133
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 108

    (65) turnleft -> TURNLEFT LPAREN . express COMMA express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 134
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 109

    (66) turnright -> TURNRIGHT LPAREN . express COMMA express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 135
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 110

    (67) servo -> SERVO LPAREN . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 136
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 111

    (68) lights -> LIGHTS LPAREN . express COMMA express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 137
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 112

    (69) display -> DISPLAY LPAREN . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 138
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 113

    (70) distance -> DISTANCE LPAREN . RPAREN

    RPAREN          shift and go to state 139


state 114

    (71) stop -> STOP LPAREN . RPAREN

    RPAREN          shift and go to state 140


state 115

    (72) while -> WHILE LPAREN . express RPAREN while1 LCURLY block RCURLY
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 141
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 116

    (74) return -> RETURN LPAREN . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 142
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 117

    (7) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 . block RCURLY
    (20) block -> . statute SEMICOLON block
    (21) block -> . empty
    (22) statute -> . cond
    (23) statute -> . assign
    (24) statute -> . call
    (25) statute -> . cin
    (26) statute -> . cout
    (27) statute -> . delay
    (28) statute -> . forward
    (29) statute -> . backward
    (30) statute -> . turnleft
    (31) statute -> . turnright
    (32) statute -> . servo
    (33) statute -> . lights
    (34) statute -> . display
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID assign1 ASSIGN express
    (47) call -> . era LPAREN paramcall RPAREN
    (52) cin -> . CIN cin1
    (59) cout -> . COUT LPAREN express cout1 RPAREN
    (62) delay -> . DELAY LPAREN express RPAREN
    (63) forward -> . FORWARD LPAREN express COMMA express RPAREN
    (64) backward -> . BACKWARD LPAREN express COMMA express RPAREN
    (65) turnleft -> . TURNLEFT LPAREN express COMMA express RPAREN
    (66) turnright -> . TURNRIGHT LPAREN express COMMA express RPAREN
    (67) servo -> . SERVO LPAREN express RPAREN
    (68) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (69) display -> . DISPLAY LPAREN express RPAREN
    (70) distance -> . DISTANCE LPAREN RPAREN
    (71) stop -> . STOP LPAREN RPAREN
    (72) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (74) return -> . RETURN LPAREN express RPAREN
    (48) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 74
    ID              shift and go to state 75
    CIN             shift and go to state 77
    COUT            shift and go to state 78
    DELAY           shift and go to state 79
    FORWARD         shift and go to state 80
    BACKWARD        shift and go to state 81
    TURNLEFT        shift and go to state 82
    TURNRIGHT       shift and go to state 83
    SERVO           shift and go to state 84
    LIGHTS          shift and go to state 85
    DISPLAY         shift and go to state 86
    DISTANCE        shift and go to state 87
    STOP            shift and go to state 88
    WHILE           shift and go to state 89
    RETURN          shift and go to state 90

    block                          shift and go to state 143
    statute                        shift and go to state 55
    empty                          shift and go to state 56
    cond                           shift and go to state 57
    assign                         shift and go to state 58
    call                           shift and go to state 59
    cin                            shift and go to state 60
    cout                           shift and go to state 61
    delay                          shift and go to state 62
    forward                        shift and go to state 63
    backward                       shift and go to state 64
    turnleft                       shift and go to state 65
    turnright                      shift and go to state 66
    servo                          shift and go to state 67
    lights                         shift and go to state 68
    display                        shift and go to state 69
    distance                       shift and go to state 70
    stop                           shift and go to state 71
    while                          shift and go to state 72
    return                         shift and go to state 73
    era                            shift and go to state 76

state 118

    (8) funcs1 -> empty .

    IF              reduce using rule 8 (funcs1 -> empty .)
    ID              reduce using rule 8 (funcs1 -> empty .)
    CIN             reduce using rule 8 (funcs1 -> empty .)
    COUT            reduce using rule 8 (funcs1 -> empty .)
    DELAY           reduce using rule 8 (funcs1 -> empty .)
    FORWARD         reduce using rule 8 (funcs1 -> empty .)
    BACKWARD        reduce using rule 8 (funcs1 -> empty .)
    TURNLEFT        reduce using rule 8 (funcs1 -> empty .)
    TURNRIGHT       reduce using rule 8 (funcs1 -> empty .)
    SERVO           reduce using rule 8 (funcs1 -> empty .)
    LIGHTS          reduce using rule 8 (funcs1 -> empty .)
    DISPLAY         reduce using rule 8 (funcs1 -> empty .)
    DISTANCE        reduce using rule 8 (funcs1 -> empty .)
    STOP            reduce using rule 8 (funcs1 -> empty .)
    WHILE           reduce using rule 8 (funcs1 -> empty .)
    RETURN          reduce using rule 8 (funcs1 -> empty .)
    RCURLY          reduce using rule 8 (funcs1 -> empty .)


state 119

    (20) block -> statute SEMICOLON block .

    RCURLY          reduce using rule 20 (block -> statute SEMICOLON block .)


state 120

    (39) cond -> IF LPAREN express . RPAREN LCURLY gotoif block RCURLY else

    RPAREN          shift and go to state 144


state 121

    (85) express -> express1 . relational express2
    (92) relational -> . exp relational1
    (93) relational -> . NOT
    (100) exp -> . term exp1
    (105) term -> . factor term1
    (110) factor -> . LPAREN express RPAREN
    (111) factor -> . constant
    (112) factor -> . call
    (80) constant -> . ID
    (81) constant -> . CTE_INT
    (82) constant -> . CTE_FLOAT
    (83) constant -> . CTE_CHAR
    (84) constant -> . CTE_BOOL
    (47) call -> . era LPAREN paramcall RPAREN
    (48) era -> . ID

    NOT             shift and go to state 147
    LPAREN          shift and go to state 150
    ID              shift and go to state 153
    CTE_INT         shift and go to state 154
    CTE_FLOAT       shift and go to state 155
    CTE_CHAR        shift and go to state 156
    CTE_BOOL        shift and go to state 157

    relational                     shift and go to state 145
    exp                            shift and go to state 146
    term                           shift and go to state 148
    factor                         shift and go to state 149
    constant                       shift and go to state 151
    call                           shift and go to state 152
    era                            shift and go to state 76

state 122

    (86) express1 -> NOTEQUALS .

    NOT             reduce using rule 86 (express1 -> NOTEQUALS .)
    LPAREN          reduce using rule 86 (express1 -> NOTEQUALS .)
    ID              reduce using rule 86 (express1 -> NOTEQUALS .)
    CTE_INT         reduce using rule 86 (express1 -> NOTEQUALS .)
    CTE_FLOAT       reduce using rule 86 (express1 -> NOTEQUALS .)
    CTE_CHAR        reduce using rule 86 (express1 -> NOTEQUALS .)
    CTE_BOOL        reduce using rule 86 (express1 -> NOTEQUALS .)


state 123

    (87) express1 -> empty .

    NOT             reduce using rule 87 (express1 -> empty .)
    LPAREN          reduce using rule 87 (express1 -> empty .)
    ID              reduce using rule 87 (express1 -> empty .)
    CTE_INT         reduce using rule 87 (express1 -> empty .)
    CTE_FLOAT       reduce using rule 87 (express1 -> empty .)
    CTE_CHAR        reduce using rule 87 (express1 -> empty .)
    CTE_BOOL        reduce using rule 87 (express1 -> empty .)


state 124

    (44) assign -> ID assign1 ASSIGN . express
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 158
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 125

    (45) assign1 -> LBRACKET express . RBRACKET

    RBRACKET        shift and go to state 159


state 126

    (47) call -> era LPAREN paramcall . RPAREN

    RPAREN          shift and go to state 160


state 127

    (49) paramcall -> express . paramcall1
    (50) paramcall1 -> . COMMA paramcall
    (51) paramcall1 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 113 (empty -> .)

    paramcall1                     shift and go to state 161
    empty                          shift and go to state 163

state 128

    (55) cin2 -> LPAREN ID . RPAREN

    RPAREN          shift and go to state 164


state 129

    (56) cin3 -> LBRACKET CTE_INT . RBRACKET LPAREN cin4 RPAREN

    RBRACKET        shift and go to state 165


state 130

    (59) cout -> COUT LPAREN express . cout1 RPAREN
    (60) cout1 -> . COMMA express cout1
    (61) cout1 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 167
    RPAREN          reduce using rule 113 (empty -> .)

    cout1                          shift and go to state 166
    empty                          shift and go to state 168

state 131

    (62) delay -> DELAY LPAREN express . RPAREN

    RPAREN          shift and go to state 169


state 132

    (63) forward -> FORWARD LPAREN express . COMMA express RPAREN

    COMMA           shift and go to state 170


state 133

    (64) backward -> BACKWARD LPAREN express . COMMA express RPAREN

    COMMA           shift and go to state 171


state 134

    (65) turnleft -> TURNLEFT LPAREN express . COMMA express RPAREN

    COMMA           shift and go to state 172


state 135

    (66) turnright -> TURNRIGHT LPAREN express . COMMA express RPAREN

    COMMA           shift and go to state 173


state 136

    (67) servo -> SERVO LPAREN express . RPAREN

    RPAREN          shift and go to state 174


state 137

    (68) lights -> LIGHTS LPAREN express . COMMA express RPAREN

    COMMA           shift and go to state 175


state 138

    (69) display -> DISPLAY LPAREN express . RPAREN

    RPAREN          shift and go to state 176


state 139

    (70) distance -> DISTANCE LPAREN RPAREN .

    SEMICOLON       reduce using rule 70 (distance -> DISTANCE LPAREN RPAREN .)


state 140

    (71) stop -> STOP LPAREN RPAREN .

    SEMICOLON       reduce using rule 71 (stop -> STOP LPAREN RPAREN .)


state 141

    (72) while -> WHILE LPAREN express . RPAREN while1 LCURLY block RCURLY

    RPAREN          shift and go to state 177


state 142

    (74) return -> RETURN LPAREN express . RPAREN

    RPAREN          shift and go to state 178


state 143

    (7) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block . RCURLY

    RCURLY          shift and go to state 179


state 144

    (39) cond -> IF LPAREN express RPAREN . LCURLY gotoif block RCURLY else

    LCURLY          shift and go to state 180


state 145

    (85) express -> express1 relational . express2
    (88) express2 -> . andor express
    (89) express2 -> . empty
    (90) andor -> . AND
    (91) andor -> . OR
    (113) empty -> .

    AND             shift and go to state 184
    OR              shift and go to state 185
    RPAREN          reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    express2                       shift and go to state 181
    andor                          shift and go to state 182
    empty                          shift and go to state 183

state 146

    (92) relational -> exp . relational1
    (94) relational1 -> . compare exp
    (95) relational1 -> . empty
    (96) compare -> . LESSTHAN
    (97) compare -> . GREATERTHAN
    (98) compare -> . EQUALS
    (99) compare -> . NOTEQUALS
    (113) empty -> .

    LESSTHAN        shift and go to state 189
    GREATERTHAN     shift and go to state 190
    EQUALS          shift and go to state 191
    NOTEQUALS       shift and go to state 192
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    relational1                    shift and go to state 186
    compare                        shift and go to state 187
    empty                          shift and go to state 188

state 147

    (93) relational -> NOT .

    AND             reduce using rule 93 (relational -> NOT .)
    OR              reduce using rule 93 (relational -> NOT .)
    RPAREN          reduce using rule 93 (relational -> NOT .)
    RBRACKET        reduce using rule 93 (relational -> NOT .)
    COMMA           reduce using rule 93 (relational -> NOT .)
    SEMICOLON       reduce using rule 93 (relational -> NOT .)


state 148

    (100) exp -> term . exp1
    (101) exp1 -> . plusminus exp
    (102) exp1 -> . empty
    (103) plusminus -> . PLUS
    (104) plusminus -> . MINUS
    (113) empty -> .

    PLUS            shift and go to state 196
    MINUS           shift and go to state 197
    LESSTHAN        reduce using rule 113 (empty -> .)
    GREATERTHAN     reduce using rule 113 (empty -> .)
    EQUALS          reduce using rule 113 (empty -> .)
    NOTEQUALS       reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    exp1                           shift and go to state 193
    plusminus                      shift and go to state 194
    empty                          shift and go to state 195

state 149

    (105) term -> factor . term1
    (106) term1 -> . multidivi term
    (107) term1 -> . empty
    (108) multidivi -> . MULTI
    (109) multidivi -> . DIVI
    (113) empty -> .

    MULTI           shift and go to state 201
    DIVI            shift and go to state 202
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    GREATERTHAN     reduce using rule 113 (empty -> .)
    EQUALS          reduce using rule 113 (empty -> .)
    NOTEQUALS       reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    term1                          shift and go to state 198
    multidivi                      shift and go to state 199
    empty                          shift and go to state 200

state 150

    (110) factor -> LPAREN . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 203
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 151

    (111) factor -> constant .

    MULTI           reduce using rule 111 (factor -> constant .)
    DIVI            reduce using rule 111 (factor -> constant .)
    PLUS            reduce using rule 111 (factor -> constant .)
    MINUS           reduce using rule 111 (factor -> constant .)
    LESSTHAN        reduce using rule 111 (factor -> constant .)
    GREATERTHAN     reduce using rule 111 (factor -> constant .)
    EQUALS          reduce using rule 111 (factor -> constant .)
    NOTEQUALS       reduce using rule 111 (factor -> constant .)
    AND             reduce using rule 111 (factor -> constant .)
    OR              reduce using rule 111 (factor -> constant .)
    RPAREN          reduce using rule 111 (factor -> constant .)
    RBRACKET        reduce using rule 111 (factor -> constant .)
    COMMA           reduce using rule 111 (factor -> constant .)
    SEMICOLON       reduce using rule 111 (factor -> constant .)


state 152

    (112) factor -> call .

    MULTI           reduce using rule 112 (factor -> call .)
    DIVI            reduce using rule 112 (factor -> call .)
    PLUS            reduce using rule 112 (factor -> call .)
    MINUS           reduce using rule 112 (factor -> call .)
    LESSTHAN        reduce using rule 112 (factor -> call .)
    GREATERTHAN     reduce using rule 112 (factor -> call .)
    EQUALS          reduce using rule 112 (factor -> call .)
    NOTEQUALS       reduce using rule 112 (factor -> call .)
    AND             reduce using rule 112 (factor -> call .)
    OR              reduce using rule 112 (factor -> call .)
    RPAREN          reduce using rule 112 (factor -> call .)
    RBRACKET        reduce using rule 112 (factor -> call .)
    COMMA           reduce using rule 112 (factor -> call .)
    SEMICOLON       reduce using rule 112 (factor -> call .)


state 153

    (80) constant -> ID .
    (48) era -> ID .

    MULTI           reduce using rule 80 (constant -> ID .)
    DIVI            reduce using rule 80 (constant -> ID .)
    PLUS            reduce using rule 80 (constant -> ID .)
    MINUS           reduce using rule 80 (constant -> ID .)
    LESSTHAN        reduce using rule 80 (constant -> ID .)
    GREATERTHAN     reduce using rule 80 (constant -> ID .)
    EQUALS          reduce using rule 80 (constant -> ID .)
    NOTEQUALS       reduce using rule 80 (constant -> ID .)
    AND             reduce using rule 80 (constant -> ID .)
    OR              reduce using rule 80 (constant -> ID .)
    RPAREN          reduce using rule 80 (constant -> ID .)
    RBRACKET        reduce using rule 80 (constant -> ID .)
    COMMA           reduce using rule 80 (constant -> ID .)
    SEMICOLON       reduce using rule 80 (constant -> ID .)
    LPAREN          reduce using rule 48 (era -> ID .)


state 154

    (81) constant -> CTE_INT .

    MULTI           reduce using rule 81 (constant -> CTE_INT .)
    DIVI            reduce using rule 81 (constant -> CTE_INT .)
    PLUS            reduce using rule 81 (constant -> CTE_INT .)
    MINUS           reduce using rule 81 (constant -> CTE_INT .)
    LESSTHAN        reduce using rule 81 (constant -> CTE_INT .)
    GREATERTHAN     reduce using rule 81 (constant -> CTE_INT .)
    EQUALS          reduce using rule 81 (constant -> CTE_INT .)
    NOTEQUALS       reduce using rule 81 (constant -> CTE_INT .)
    AND             reduce using rule 81 (constant -> CTE_INT .)
    OR              reduce using rule 81 (constant -> CTE_INT .)
    RPAREN          reduce using rule 81 (constant -> CTE_INT .)
    RBRACKET        reduce using rule 81 (constant -> CTE_INT .)
    COMMA           reduce using rule 81 (constant -> CTE_INT .)
    SEMICOLON       reduce using rule 81 (constant -> CTE_INT .)


state 155

    (82) constant -> CTE_FLOAT .

    MULTI           reduce using rule 82 (constant -> CTE_FLOAT .)
    DIVI            reduce using rule 82 (constant -> CTE_FLOAT .)
    PLUS            reduce using rule 82 (constant -> CTE_FLOAT .)
    MINUS           reduce using rule 82 (constant -> CTE_FLOAT .)
    LESSTHAN        reduce using rule 82 (constant -> CTE_FLOAT .)
    GREATERTHAN     reduce using rule 82 (constant -> CTE_FLOAT .)
    EQUALS          reduce using rule 82 (constant -> CTE_FLOAT .)
    NOTEQUALS       reduce using rule 82 (constant -> CTE_FLOAT .)
    AND             reduce using rule 82 (constant -> CTE_FLOAT .)
    OR              reduce using rule 82 (constant -> CTE_FLOAT .)
    RPAREN          reduce using rule 82 (constant -> CTE_FLOAT .)
    RBRACKET        reduce using rule 82 (constant -> CTE_FLOAT .)
    COMMA           reduce using rule 82 (constant -> CTE_FLOAT .)
    SEMICOLON       reduce using rule 82 (constant -> CTE_FLOAT .)


state 156

    (83) constant -> CTE_CHAR .

    MULTI           reduce using rule 83 (constant -> CTE_CHAR .)
    DIVI            reduce using rule 83 (constant -> CTE_CHAR .)
    PLUS            reduce using rule 83 (constant -> CTE_CHAR .)
    MINUS           reduce using rule 83 (constant -> CTE_CHAR .)
    LESSTHAN        reduce using rule 83 (constant -> CTE_CHAR .)
    GREATERTHAN     reduce using rule 83 (constant -> CTE_CHAR .)
    EQUALS          reduce using rule 83 (constant -> CTE_CHAR .)
    NOTEQUALS       reduce using rule 83 (constant -> CTE_CHAR .)
    AND             reduce using rule 83 (constant -> CTE_CHAR .)
    OR              reduce using rule 83 (constant -> CTE_CHAR .)
    RPAREN          reduce using rule 83 (constant -> CTE_CHAR .)
    RBRACKET        reduce using rule 83 (constant -> CTE_CHAR .)
    COMMA           reduce using rule 83 (constant -> CTE_CHAR .)
    SEMICOLON       reduce using rule 83 (constant -> CTE_CHAR .)


state 157

    (84) constant -> CTE_BOOL .

    MULTI           reduce using rule 84 (constant -> CTE_BOOL .)
    DIVI            reduce using rule 84 (constant -> CTE_BOOL .)
    PLUS            reduce using rule 84 (constant -> CTE_BOOL .)
    MINUS           reduce using rule 84 (constant -> CTE_BOOL .)
    LESSTHAN        reduce using rule 84 (constant -> CTE_BOOL .)
    GREATERTHAN     reduce using rule 84 (constant -> CTE_BOOL .)
    EQUALS          reduce using rule 84 (constant -> CTE_BOOL .)
    NOTEQUALS       reduce using rule 84 (constant -> CTE_BOOL .)
    AND             reduce using rule 84 (constant -> CTE_BOOL .)
    OR              reduce using rule 84 (constant -> CTE_BOOL .)
    RPAREN          reduce using rule 84 (constant -> CTE_BOOL .)
    RBRACKET        reduce using rule 84 (constant -> CTE_BOOL .)
    COMMA           reduce using rule 84 (constant -> CTE_BOOL .)
    SEMICOLON       reduce using rule 84 (constant -> CTE_BOOL .)


state 158

    (44) assign -> ID assign1 ASSIGN express .

    SEMICOLON       reduce using rule 44 (assign -> ID assign1 ASSIGN express .)


state 159

    (45) assign1 -> LBRACKET express RBRACKET .

    ASSIGN          reduce using rule 45 (assign1 -> LBRACKET express RBRACKET .)


state 160

    (47) call -> era LPAREN paramcall RPAREN .

    SEMICOLON       reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    MULTI           reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    DIVI            reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    PLUS            reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    MINUS           reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    LESSTHAN        reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    GREATERTHAN     reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    EQUALS          reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    NOTEQUALS       reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    AND             reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    OR              reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    RPAREN          reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    RBRACKET        reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)
    COMMA           reduce using rule 47 (call -> era LPAREN paramcall RPAREN .)


state 161

    (49) paramcall -> express paramcall1 .

    RPAREN          reduce using rule 49 (paramcall -> express paramcall1 .)


state 162

    (50) paramcall1 -> COMMA . paramcall
    (49) paramcall -> . express paramcall1
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    paramcall                      shift and go to state 204
    express                        shift and go to state 127
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 163

    (51) paramcall1 -> empty .

    RPAREN          reduce using rule 51 (paramcall1 -> empty .)


state 164

    (55) cin2 -> LPAREN ID RPAREN .

    SEMICOLON       reduce using rule 55 (cin2 -> LPAREN ID RPAREN .)


state 165

    (56) cin3 -> LBRACKET CTE_INT RBRACKET . LPAREN cin4 RPAREN

    LPAREN          shift and go to state 205


state 166

    (59) cout -> COUT LPAREN express cout1 . RPAREN

    RPAREN          shift and go to state 206


state 167

    (60) cout1 -> COMMA . express cout1
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 207
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 168

    (61) cout1 -> empty .

    RPAREN          reduce using rule 61 (cout1 -> empty .)


state 169

    (62) delay -> DELAY LPAREN express RPAREN .

    SEMICOLON       reduce using rule 62 (delay -> DELAY LPAREN express RPAREN .)


state 170

    (63) forward -> FORWARD LPAREN express COMMA . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 208
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 171

    (64) backward -> BACKWARD LPAREN express COMMA . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 209
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 172

    (65) turnleft -> TURNLEFT LPAREN express COMMA . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 210
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 173

    (66) turnright -> TURNRIGHT LPAREN express COMMA . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 211
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 174

    (67) servo -> SERVO LPAREN express RPAREN .

    SEMICOLON       reduce using rule 67 (servo -> SERVO LPAREN express RPAREN .)


state 175

    (68) lights -> LIGHTS LPAREN express COMMA . express RPAREN
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 212
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 176

    (69) display -> DISPLAY LPAREN express RPAREN .

    SEMICOLON       reduce using rule 69 (display -> DISPLAY LPAREN express RPAREN .)


state 177

    (72) while -> WHILE LPAREN express RPAREN . while1 LCURLY block RCURLY
    (73) while1 -> . empty
    (113) empty -> .

    LCURLY          reduce using rule 113 (empty -> .)

    while1                         shift and go to state 213
    empty                          shift and go to state 214

state 178

    (74) return -> RETURN LPAREN express RPAREN .

    SEMICOLON       reduce using rule 74 (return -> RETURN LPAREN express RPAREN .)


state 179

    (7) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY .

    FUNCDEF         reduce using rule 7 (funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY .)
    MAIN            reduce using rule 7 (funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY .)


state 180

    (39) cond -> IF LPAREN express RPAREN LCURLY . gotoif block RCURLY else
    (40) gotoif -> . empty
    (113) empty -> .

    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISPLAY         reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    gotoif                         shift and go to state 215
    empty                          shift and go to state 216

state 181

    (85) express -> express1 relational express2 .

    RPAREN          reduce using rule 85 (express -> express1 relational express2 .)
    RBRACKET        reduce using rule 85 (express -> express1 relational express2 .)
    COMMA           reduce using rule 85 (express -> express1 relational express2 .)
    SEMICOLON       reduce using rule 85 (express -> express1 relational express2 .)


state 182

    (88) express2 -> andor . express
    (85) express -> . express1 relational express2
    (86) express1 -> . NOTEQUALS
    (87) express1 -> . empty
    (113) empty -> .

    NOTEQUALS       shift and go to state 122
    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    express                        shift and go to state 217
    express1                       shift and go to state 121
    empty                          shift and go to state 123

state 183

    (89) express2 -> empty .

    RPAREN          reduce using rule 89 (express2 -> empty .)
    RBRACKET        reduce using rule 89 (express2 -> empty .)
    COMMA           reduce using rule 89 (express2 -> empty .)
    SEMICOLON       reduce using rule 89 (express2 -> empty .)


state 184

    (90) andor -> AND .

    NOTEQUALS       reduce using rule 90 (andor -> AND .)
    NOT             reduce using rule 90 (andor -> AND .)
    LPAREN          reduce using rule 90 (andor -> AND .)
    ID              reduce using rule 90 (andor -> AND .)
    CTE_INT         reduce using rule 90 (andor -> AND .)
    CTE_FLOAT       reduce using rule 90 (andor -> AND .)
    CTE_CHAR        reduce using rule 90 (andor -> AND .)
    CTE_BOOL        reduce using rule 90 (andor -> AND .)


state 185

    (91) andor -> OR .

    NOTEQUALS       reduce using rule 91 (andor -> OR .)
    NOT             reduce using rule 91 (andor -> OR .)
    LPAREN          reduce using rule 91 (andor -> OR .)
    ID              reduce using rule 91 (andor -> OR .)
    CTE_INT         reduce using rule 91 (andor -> OR .)
    CTE_FLOAT       reduce using rule 91 (andor -> OR .)
    CTE_CHAR        reduce using rule 91 (andor -> OR .)
    CTE_BOOL        reduce using rule 91 (andor -> OR .)


state 186

    (92) relational -> exp relational1 .

    AND             reduce using rule 92 (relational -> exp relational1 .)
    OR              reduce using rule 92 (relational -> exp relational1 .)
    RPAREN          reduce using rule 92 (relational -> exp relational1 .)
    RBRACKET        reduce using rule 92 (relational -> exp relational1 .)
    COMMA           reduce using rule 92 (relational -> exp relational1 .)
    SEMICOLON       reduce using rule 92 (relational -> exp relational1 .)


state 187

    (94) relational1 -> compare . exp
    (100) exp -> . term exp1
    (105) term -> . factor term1
    (110) factor -> . LPAREN express RPAREN
    (111) factor -> . constant
    (112) factor -> . call
    (80) constant -> . ID
    (81) constant -> . CTE_INT
    (82) constant -> . CTE_FLOAT
    (83) constant -> . CTE_CHAR
    (84) constant -> . CTE_BOOL
    (47) call -> . era LPAREN paramcall RPAREN
    (48) era -> . ID

    LPAREN          shift and go to state 150
    ID              shift and go to state 153
    CTE_INT         shift and go to state 154
    CTE_FLOAT       shift and go to state 155
    CTE_CHAR        shift and go to state 156
    CTE_BOOL        shift and go to state 157

    exp                            shift and go to state 218
    term                           shift and go to state 148
    factor                         shift and go to state 149
    constant                       shift and go to state 151
    call                           shift and go to state 152
    era                            shift and go to state 76

state 188

    (95) relational1 -> empty .

    AND             reduce using rule 95 (relational1 -> empty .)
    OR              reduce using rule 95 (relational1 -> empty .)
    RPAREN          reduce using rule 95 (relational1 -> empty .)
    RBRACKET        reduce using rule 95 (relational1 -> empty .)
    COMMA           reduce using rule 95 (relational1 -> empty .)
    SEMICOLON       reduce using rule 95 (relational1 -> empty .)


state 189

    (96) compare -> LESSTHAN .

    LPAREN          reduce using rule 96 (compare -> LESSTHAN .)
    ID              reduce using rule 96 (compare -> LESSTHAN .)
    CTE_INT         reduce using rule 96 (compare -> LESSTHAN .)
    CTE_FLOAT       reduce using rule 96 (compare -> LESSTHAN .)
    CTE_CHAR        reduce using rule 96 (compare -> LESSTHAN .)
    CTE_BOOL        reduce using rule 96 (compare -> LESSTHAN .)


state 190

    (97) compare -> GREATERTHAN .

    LPAREN          reduce using rule 97 (compare -> GREATERTHAN .)
    ID              reduce using rule 97 (compare -> GREATERTHAN .)
    CTE_INT         reduce using rule 97 (compare -> GREATERTHAN .)
    CTE_FLOAT       reduce using rule 97 (compare -> GREATERTHAN .)
    CTE_CHAR        reduce using rule 97 (compare -> GREATERTHAN .)
    CTE_BOOL        reduce using rule 97 (compare -> GREATERTHAN .)


state 191

    (98) compare -> EQUALS .

    LPAREN          reduce using rule 98 (compare -> EQUALS .)
    ID              reduce using rule 98 (compare -> EQUALS .)
    CTE_INT         reduce using rule 98 (compare -> EQUALS .)
    CTE_FLOAT       reduce using rule 98 (compare -> EQUALS .)
    CTE_CHAR        reduce using rule 98 (compare -> EQUALS .)
    CTE_BOOL        reduce using rule 98 (compare -> EQUALS .)


state 192

    (99) compare -> NOTEQUALS .

    LPAREN          reduce using rule 99 (compare -> NOTEQUALS .)
    ID              reduce using rule 99 (compare -> NOTEQUALS .)
    CTE_INT         reduce using rule 99 (compare -> NOTEQUALS .)
    CTE_FLOAT       reduce using rule 99 (compare -> NOTEQUALS .)
    CTE_CHAR        reduce using rule 99 (compare -> NOTEQUALS .)
    CTE_BOOL        reduce using rule 99 (compare -> NOTEQUALS .)


state 193

    (100) exp -> term exp1 .

    LESSTHAN        reduce using rule 100 (exp -> term exp1 .)
    GREATERTHAN     reduce using rule 100 (exp -> term exp1 .)
    EQUALS          reduce using rule 100 (exp -> term exp1 .)
    NOTEQUALS       reduce using rule 100 (exp -> term exp1 .)
    AND             reduce using rule 100 (exp -> term exp1 .)
    OR              reduce using rule 100 (exp -> term exp1 .)
    RPAREN          reduce using rule 100 (exp -> term exp1 .)
    RBRACKET        reduce using rule 100 (exp -> term exp1 .)
    COMMA           reduce using rule 100 (exp -> term exp1 .)
    SEMICOLON       reduce using rule 100 (exp -> term exp1 .)


state 194

    (101) exp1 -> plusminus . exp
    (100) exp -> . term exp1
    (105) term -> . factor term1
    (110) factor -> . LPAREN express RPAREN
    (111) factor -> . constant
    (112) factor -> . call
    (80) constant -> . ID
    (81) constant -> . CTE_INT
    (82) constant -> . CTE_FLOAT
    (83) constant -> . CTE_CHAR
    (84) constant -> . CTE_BOOL
    (47) call -> . era LPAREN paramcall RPAREN
    (48) era -> . ID

    LPAREN          shift and go to state 150
    ID              shift and go to state 153
    CTE_INT         shift and go to state 154
    CTE_FLOAT       shift and go to state 155
    CTE_CHAR        shift and go to state 156
    CTE_BOOL        shift and go to state 157

    exp                            shift and go to state 219
    term                           shift and go to state 148
    factor                         shift and go to state 149
    constant                       shift and go to state 151
    call                           shift and go to state 152
    era                            shift and go to state 76

state 195

    (102) exp1 -> empty .

    LESSTHAN        reduce using rule 102 (exp1 -> empty .)
    GREATERTHAN     reduce using rule 102 (exp1 -> empty .)
    EQUALS          reduce using rule 102 (exp1 -> empty .)
    NOTEQUALS       reduce using rule 102 (exp1 -> empty .)
    AND             reduce using rule 102 (exp1 -> empty .)
    OR              reduce using rule 102 (exp1 -> empty .)
    RPAREN          reduce using rule 102 (exp1 -> empty .)
    RBRACKET        reduce using rule 102 (exp1 -> empty .)
    COMMA           reduce using rule 102 (exp1 -> empty .)
    SEMICOLON       reduce using rule 102 (exp1 -> empty .)


state 196

    (103) plusminus -> PLUS .

    LPAREN          reduce using rule 103 (plusminus -> PLUS .)
    ID              reduce using rule 103 (plusminus -> PLUS .)
    CTE_INT         reduce using rule 103 (plusminus -> PLUS .)
    CTE_FLOAT       reduce using rule 103 (plusminus -> PLUS .)
    CTE_CHAR        reduce using rule 103 (plusminus -> PLUS .)
    CTE_BOOL        reduce using rule 103 (plusminus -> PLUS .)


state 197

    (104) plusminus -> MINUS .

    LPAREN          reduce using rule 104 (plusminus -> MINUS .)
    ID              reduce using rule 104 (plusminus -> MINUS .)
    CTE_INT         reduce using rule 104 (plusminus -> MINUS .)
    CTE_FLOAT       reduce using rule 104 (plusminus -> MINUS .)
    CTE_CHAR        reduce using rule 104 (plusminus -> MINUS .)
    CTE_BOOL        reduce using rule 104 (plusminus -> MINUS .)


state 198

    (105) term -> factor term1 .

    PLUS            reduce using rule 105 (term -> factor term1 .)
    MINUS           reduce using rule 105 (term -> factor term1 .)
    LESSTHAN        reduce using rule 105 (term -> factor term1 .)
    GREATERTHAN     reduce using rule 105 (term -> factor term1 .)
    EQUALS          reduce using rule 105 (term -> factor term1 .)
    NOTEQUALS       reduce using rule 105 (term -> factor term1 .)
    AND             reduce using rule 105 (term -> factor term1 .)
    OR              reduce using rule 105 (term -> factor term1 .)
    RPAREN          reduce using rule 105 (term -> factor term1 .)
    RBRACKET        reduce using rule 105 (term -> factor term1 .)
    COMMA           reduce using rule 105 (term -> factor term1 .)
    SEMICOLON       reduce using rule 105 (term -> factor term1 .)


state 199

    (106) term1 -> multidivi . term
    (105) term -> . factor term1
    (110) factor -> . LPAREN express RPAREN
    (111) factor -> . constant
    (112) factor -> . call
    (80) constant -> . ID
    (81) constant -> . CTE_INT
    (82) constant -> . CTE_FLOAT
    (83) constant -> . CTE_CHAR
    (84) constant -> . CTE_BOOL
    (47) call -> . era LPAREN paramcall RPAREN
    (48) era -> . ID

    LPAREN          shift and go to state 150
    ID              shift and go to state 153
    CTE_INT         shift and go to state 154
    CTE_FLOAT       shift and go to state 155
    CTE_CHAR        shift and go to state 156
    CTE_BOOL        shift and go to state 157

    term                           shift and go to state 220
    factor                         shift and go to state 149
    constant                       shift and go to state 151
    call                           shift and go to state 152
    era                            shift and go to state 76

state 200

    (107) term1 -> empty .

    PLUS            reduce using rule 107 (term1 -> empty .)
    MINUS           reduce using rule 107 (term1 -> empty .)
    LESSTHAN        reduce using rule 107 (term1 -> empty .)
    GREATERTHAN     reduce using rule 107 (term1 -> empty .)
    EQUALS          reduce using rule 107 (term1 -> empty .)
    NOTEQUALS       reduce using rule 107 (term1 -> empty .)
    AND             reduce using rule 107 (term1 -> empty .)
    OR              reduce using rule 107 (term1 -> empty .)
    RPAREN          reduce using rule 107 (term1 -> empty .)
    RBRACKET        reduce using rule 107 (term1 -> empty .)
    COMMA           reduce using rule 107 (term1 -> empty .)
    SEMICOLON       reduce using rule 107 (term1 -> empty .)


state 201

    (108) multidivi -> MULTI .

    LPAREN          reduce using rule 108 (multidivi -> MULTI .)
    ID              reduce using rule 108 (multidivi -> MULTI .)
    CTE_INT         reduce using rule 108 (multidivi -> MULTI .)
    CTE_FLOAT       reduce using rule 108 (multidivi -> MULTI .)
    CTE_CHAR        reduce using rule 108 (multidivi -> MULTI .)
    CTE_BOOL        reduce using rule 108 (multidivi -> MULTI .)


state 202

    (109) multidivi -> DIVI .

    LPAREN          reduce using rule 109 (multidivi -> DIVI .)
    ID              reduce using rule 109 (multidivi -> DIVI .)
    CTE_INT         reduce using rule 109 (multidivi -> DIVI .)
    CTE_FLOAT       reduce using rule 109 (multidivi -> DIVI .)
    CTE_CHAR        reduce using rule 109 (multidivi -> DIVI .)
    CTE_BOOL        reduce using rule 109 (multidivi -> DIVI .)


state 203

    (110) factor -> LPAREN express . RPAREN

    RPAREN          shift and go to state 221


state 204

    (50) paramcall1 -> COMMA paramcall .

    RPAREN          reduce using rule 50 (paramcall1 -> COMMA paramcall .)


state 205

    (56) cin3 -> LBRACKET CTE_INT RBRACKET LPAREN . cin4 RPAREN
    (57) cin4 -> . COMMA ID cin4
    (58) cin4 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 223
    RPAREN          reduce using rule 113 (empty -> .)

    cin4                           shift and go to state 222
    empty                          shift and go to state 224

state 206

    (59) cout -> COUT LPAREN express cout1 RPAREN .

    SEMICOLON       reduce using rule 59 (cout -> COUT LPAREN express cout1 RPAREN .)


state 207

    (60) cout1 -> COMMA express . cout1
    (60) cout1 -> . COMMA express cout1
    (61) cout1 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 167
    RPAREN          reduce using rule 113 (empty -> .)

    cout1                          shift and go to state 225
    empty                          shift and go to state 168

state 208

    (63) forward -> FORWARD LPAREN express COMMA express . RPAREN

    RPAREN          shift and go to state 226


state 209

    (64) backward -> BACKWARD LPAREN express COMMA express . RPAREN

    RPAREN          shift and go to state 227


state 210

    (65) turnleft -> TURNLEFT LPAREN express COMMA express . RPAREN

    RPAREN          shift and go to state 228


state 211

    (66) turnright -> TURNRIGHT LPAREN express COMMA express . RPAREN

    RPAREN          shift and go to state 229


state 212

    (68) lights -> LIGHTS LPAREN express COMMA express . RPAREN

    RPAREN          shift and go to state 230


state 213

    (72) while -> WHILE LPAREN express RPAREN while1 . LCURLY block RCURLY

    LCURLY          shift and go to state 231


state 214

    (73) while1 -> empty .

    LCURLY          reduce using rule 73 (while1 -> empty .)


state 215

    (39) cond -> IF LPAREN express RPAREN LCURLY gotoif . block RCURLY else
    (20) block -> . statute SEMICOLON block
    (21) block -> . empty
    (22) statute -> . cond
    (23) statute -> . assign
    (24) statute -> . call
    (25) statute -> . cin
    (26) statute -> . cout
    (27) statute -> . delay
    (28) statute -> . forward
    (29) statute -> . backward
    (30) statute -> . turnleft
    (31) statute -> . turnright
    (32) statute -> . servo
    (33) statute -> . lights
    (34) statute -> . display
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID assign1 ASSIGN express
    (47) call -> . era LPAREN paramcall RPAREN
    (52) cin -> . CIN cin1
    (59) cout -> . COUT LPAREN express cout1 RPAREN
    (62) delay -> . DELAY LPAREN express RPAREN
    (63) forward -> . FORWARD LPAREN express COMMA express RPAREN
    (64) backward -> . BACKWARD LPAREN express COMMA express RPAREN
    (65) turnleft -> . TURNLEFT LPAREN express COMMA express RPAREN
    (66) turnright -> . TURNRIGHT LPAREN express COMMA express RPAREN
    (67) servo -> . SERVO LPAREN express RPAREN
    (68) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (69) display -> . DISPLAY LPAREN express RPAREN
    (70) distance -> . DISTANCE LPAREN RPAREN
    (71) stop -> . STOP LPAREN RPAREN
    (72) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (74) return -> . RETURN LPAREN express RPAREN
    (48) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 74
    ID              shift and go to state 75
    CIN             shift and go to state 77
    COUT            shift and go to state 78
    DELAY           shift and go to state 79
    FORWARD         shift and go to state 80
    BACKWARD        shift and go to state 81
    TURNLEFT        shift and go to state 82
    TURNRIGHT       shift and go to state 83
    SERVO           shift and go to state 84
    LIGHTS          shift and go to state 85
    DISPLAY         shift and go to state 86
    DISTANCE        shift and go to state 87
    STOP            shift and go to state 88
    WHILE           shift and go to state 89
    RETURN          shift and go to state 90

    block                          shift and go to state 232
    statute                        shift and go to state 55
    empty                          shift and go to state 56
    cond                           shift and go to state 57
    assign                         shift and go to state 58
    call                           shift and go to state 59
    cin                            shift and go to state 60
    cout                           shift and go to state 61
    delay                          shift and go to state 62
    forward                        shift and go to state 63
    backward                       shift and go to state 64
    turnleft                       shift and go to state 65
    turnright                      shift and go to state 66
    servo                          shift and go to state 67
    lights                         shift and go to state 68
    display                        shift and go to state 69
    distance                       shift and go to state 70
    stop                           shift and go to state 71
    while                          shift and go to state 72
    return                         shift and go to state 73
    era                            shift and go to state 76

state 216

    (40) gotoif -> empty .

    IF              reduce using rule 40 (gotoif -> empty .)
    ID              reduce using rule 40 (gotoif -> empty .)
    CIN             reduce using rule 40 (gotoif -> empty .)
    COUT            reduce using rule 40 (gotoif -> empty .)
    DELAY           reduce using rule 40 (gotoif -> empty .)
    FORWARD         reduce using rule 40 (gotoif -> empty .)
    BACKWARD        reduce using rule 40 (gotoif -> empty .)
    TURNLEFT        reduce using rule 40 (gotoif -> empty .)
    TURNRIGHT       reduce using rule 40 (gotoif -> empty .)
    SERVO           reduce using rule 40 (gotoif -> empty .)
    LIGHTS          reduce using rule 40 (gotoif -> empty .)
    DISPLAY         reduce using rule 40 (gotoif -> empty .)
    DISTANCE        reduce using rule 40 (gotoif -> empty .)
    STOP            reduce using rule 40 (gotoif -> empty .)
    WHILE           reduce using rule 40 (gotoif -> empty .)
    RETURN          reduce using rule 40 (gotoif -> empty .)
    RCURLY          reduce using rule 40 (gotoif -> empty .)


state 217

    (88) express2 -> andor express .

    RPAREN          reduce using rule 88 (express2 -> andor express .)
    RBRACKET        reduce using rule 88 (express2 -> andor express .)
    COMMA           reduce using rule 88 (express2 -> andor express .)
    SEMICOLON       reduce using rule 88 (express2 -> andor express .)


state 218

    (94) relational1 -> compare exp .

    AND             reduce using rule 94 (relational1 -> compare exp .)
    OR              reduce using rule 94 (relational1 -> compare exp .)
    RPAREN          reduce using rule 94 (relational1 -> compare exp .)
    RBRACKET        reduce using rule 94 (relational1 -> compare exp .)
    COMMA           reduce using rule 94 (relational1 -> compare exp .)
    SEMICOLON       reduce using rule 94 (relational1 -> compare exp .)


state 219

    (101) exp1 -> plusminus exp .

    LESSTHAN        reduce using rule 101 (exp1 -> plusminus exp .)
    GREATERTHAN     reduce using rule 101 (exp1 -> plusminus exp .)
    EQUALS          reduce using rule 101 (exp1 -> plusminus exp .)
    NOTEQUALS       reduce using rule 101 (exp1 -> plusminus exp .)
    AND             reduce using rule 101 (exp1 -> plusminus exp .)
    OR              reduce using rule 101 (exp1 -> plusminus exp .)
    RPAREN          reduce using rule 101 (exp1 -> plusminus exp .)
    RBRACKET        reduce using rule 101 (exp1 -> plusminus exp .)
    COMMA           reduce using rule 101 (exp1 -> plusminus exp .)
    SEMICOLON       reduce using rule 101 (exp1 -> plusminus exp .)


state 220

    (106) term1 -> multidivi term .

    PLUS            reduce using rule 106 (term1 -> multidivi term .)
    MINUS           reduce using rule 106 (term1 -> multidivi term .)
    LESSTHAN        reduce using rule 106 (term1 -> multidivi term .)
    GREATERTHAN     reduce using rule 106 (term1 -> multidivi term .)
    EQUALS          reduce using rule 106 (term1 -> multidivi term .)
    NOTEQUALS       reduce using rule 106 (term1 -> multidivi term .)
    AND             reduce using rule 106 (term1 -> multidivi term .)
    OR              reduce using rule 106 (term1 -> multidivi term .)
    RPAREN          reduce using rule 106 (term1 -> multidivi term .)
    RBRACKET        reduce using rule 106 (term1 -> multidivi term .)
    COMMA           reduce using rule 106 (term1 -> multidivi term .)
    SEMICOLON       reduce using rule 106 (term1 -> multidivi term .)


state 221

    (110) factor -> LPAREN express RPAREN .

    MULTI           reduce using rule 110 (factor -> LPAREN express RPAREN .)
    DIVI            reduce using rule 110 (factor -> LPAREN express RPAREN .)
    PLUS            reduce using rule 110 (factor -> LPAREN express RPAREN .)
    MINUS           reduce using rule 110 (factor -> LPAREN express RPAREN .)
    LESSTHAN        reduce using rule 110 (factor -> LPAREN express RPAREN .)
    GREATERTHAN     reduce using rule 110 (factor -> LPAREN express RPAREN .)
    EQUALS          reduce using rule 110 (factor -> LPAREN express RPAREN .)
    NOTEQUALS       reduce using rule 110 (factor -> LPAREN express RPAREN .)
    AND             reduce using rule 110 (factor -> LPAREN express RPAREN .)
    OR              reduce using rule 110 (factor -> LPAREN express RPAREN .)
    RPAREN          reduce using rule 110 (factor -> LPAREN express RPAREN .)
    RBRACKET        reduce using rule 110 (factor -> LPAREN express RPAREN .)
    COMMA           reduce using rule 110 (factor -> LPAREN express RPAREN .)
    SEMICOLON       reduce using rule 110 (factor -> LPAREN express RPAREN .)


state 222

    (56) cin3 -> LBRACKET CTE_INT RBRACKET LPAREN cin4 . RPAREN

    RPAREN          shift and go to state 233


state 223

    (57) cin4 -> COMMA . ID cin4

    ID              shift and go to state 234


state 224

    (58) cin4 -> empty .

    RPAREN          reduce using rule 58 (cin4 -> empty .)


state 225

    (60) cout1 -> COMMA express cout1 .

    RPAREN          reduce using rule 60 (cout1 -> COMMA express cout1 .)


state 226

    (63) forward -> FORWARD LPAREN express COMMA express RPAREN .

    SEMICOLON       reduce using rule 63 (forward -> FORWARD LPAREN express COMMA express RPAREN .)


state 227

    (64) backward -> BACKWARD LPAREN express COMMA express RPAREN .

    SEMICOLON       reduce using rule 64 (backward -> BACKWARD LPAREN express COMMA express RPAREN .)


state 228

    (65) turnleft -> TURNLEFT LPAREN express COMMA express RPAREN .

    SEMICOLON       reduce using rule 65 (turnleft -> TURNLEFT LPAREN express COMMA express RPAREN .)


state 229

    (66) turnright -> TURNRIGHT LPAREN express COMMA express RPAREN .

    SEMICOLON       reduce using rule 66 (turnright -> TURNRIGHT LPAREN express COMMA express RPAREN .)


state 230

    (68) lights -> LIGHTS LPAREN express COMMA express RPAREN .

    SEMICOLON       reduce using rule 68 (lights -> LIGHTS LPAREN express COMMA express RPAREN .)


state 231

    (72) while -> WHILE LPAREN express RPAREN while1 LCURLY . block RCURLY
    (20) block -> . statute SEMICOLON block
    (21) block -> . empty
    (22) statute -> . cond
    (23) statute -> . assign
    (24) statute -> . call
    (25) statute -> . cin
    (26) statute -> . cout
    (27) statute -> . delay
    (28) statute -> . forward
    (29) statute -> . backward
    (30) statute -> . turnleft
    (31) statute -> . turnright
    (32) statute -> . servo
    (33) statute -> . lights
    (34) statute -> . display
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID assign1 ASSIGN express
    (47) call -> . era LPAREN paramcall RPAREN
    (52) cin -> . CIN cin1
    (59) cout -> . COUT LPAREN express cout1 RPAREN
    (62) delay -> . DELAY LPAREN express RPAREN
    (63) forward -> . FORWARD LPAREN express COMMA express RPAREN
    (64) backward -> . BACKWARD LPAREN express COMMA express RPAREN
    (65) turnleft -> . TURNLEFT LPAREN express COMMA express RPAREN
    (66) turnright -> . TURNRIGHT LPAREN express COMMA express RPAREN
    (67) servo -> . SERVO LPAREN express RPAREN
    (68) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (69) display -> . DISPLAY LPAREN express RPAREN
    (70) distance -> . DISTANCE LPAREN RPAREN
    (71) stop -> . STOP LPAREN RPAREN
    (72) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (74) return -> . RETURN LPAREN express RPAREN
    (48) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 74
    ID              shift and go to state 75
    CIN             shift and go to state 77
    COUT            shift and go to state 78
    DELAY           shift and go to state 79
    FORWARD         shift and go to state 80
    BACKWARD        shift and go to state 81
    TURNLEFT        shift and go to state 82
    TURNRIGHT       shift and go to state 83
    SERVO           shift and go to state 84
    LIGHTS          shift and go to state 85
    DISPLAY         shift and go to state 86
    DISTANCE        shift and go to state 87
    STOP            shift and go to state 88
    WHILE           shift and go to state 89
    RETURN          shift and go to state 90

    block                          shift and go to state 235
    statute                        shift and go to state 55
    empty                          shift and go to state 56
    cond                           shift and go to state 57
    assign                         shift and go to state 58
    call                           shift and go to state 59
    cin                            shift and go to state 60
    cout                           shift and go to state 61
    delay                          shift and go to state 62
    forward                        shift and go to state 63
    backward                       shift and go to state 64
    turnleft                       shift and go to state 65
    turnright                      shift and go to state 66
    servo                          shift and go to state 67
    lights                         shift and go to state 68
    display                        shift and go to state 69
    distance                       shift and go to state 70
    stop                           shift and go to state 71
    while                          shift and go to state 72
    return                         shift and go to state 73
    era                            shift and go to state 76

state 232

    (39) cond -> IF LPAREN express RPAREN LCURLY gotoif block . RCURLY else

    RCURLY          shift and go to state 236


state 233

    (56) cin3 -> LBRACKET CTE_INT RBRACKET LPAREN cin4 RPAREN .

    SEMICOLON       reduce using rule 56 (cin3 -> LBRACKET CTE_INT RBRACKET LPAREN cin4 RPAREN .)


state 234

    (57) cin4 -> COMMA ID . cin4
    (57) cin4 -> . COMMA ID cin4
    (58) cin4 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 223
    RPAREN          reduce using rule 113 (empty -> .)

    cin4                           shift and go to state 237
    empty                          shift and go to state 224

state 235

    (72) while -> WHILE LPAREN express RPAREN while1 LCURLY block . RCURLY

    RCURLY          shift and go to state 238


state 236

    (39) cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY . else
    (41) else -> . ELSE LCURLY gotoelse block RCURLY else
    (42) else -> . empty
    (113) empty -> .

    ELSE            shift and go to state 240
    SEMICOLON       reduce using rule 113 (empty -> .)

    else                           shift and go to state 239
    empty                          shift and go to state 241

state 237

    (57) cin4 -> COMMA ID cin4 .

    RPAREN          reduce using rule 57 (cin4 -> COMMA ID cin4 .)


state 238

    (72) while -> WHILE LPAREN express RPAREN while1 LCURLY block RCURLY .

    SEMICOLON       reduce using rule 72 (while -> WHILE LPAREN express RPAREN while1 LCURLY block RCURLY .)


state 239

    (39) cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY else .

    SEMICOLON       reduce using rule 39 (cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY else .)


state 240

    (41) else -> ELSE . LCURLY gotoelse block RCURLY else

    LCURLY          shift and go to state 242


state 241

    (42) else -> empty .

    SEMICOLON       reduce using rule 42 (else -> empty .)


state 242

    (41) else -> ELSE LCURLY . gotoelse block RCURLY else
    (43) gotoelse -> . empty
    (113) empty -> .

    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISPLAY         reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    gotoelse                       shift and go to state 243
    empty                          shift and go to state 244

state 243

    (41) else -> ELSE LCURLY gotoelse . block RCURLY else
    (20) block -> . statute SEMICOLON block
    (21) block -> . empty
    (22) statute -> . cond
    (23) statute -> . assign
    (24) statute -> . call
    (25) statute -> . cin
    (26) statute -> . cout
    (27) statute -> . delay
    (28) statute -> . forward
    (29) statute -> . backward
    (30) statute -> . turnleft
    (31) statute -> . turnright
    (32) statute -> . servo
    (33) statute -> . lights
    (34) statute -> . display
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID assign1 ASSIGN express
    (47) call -> . era LPAREN paramcall RPAREN
    (52) cin -> . CIN cin1
    (59) cout -> . COUT LPAREN express cout1 RPAREN
    (62) delay -> . DELAY LPAREN express RPAREN
    (63) forward -> . FORWARD LPAREN express COMMA express RPAREN
    (64) backward -> . BACKWARD LPAREN express COMMA express RPAREN
    (65) turnleft -> . TURNLEFT LPAREN express COMMA express RPAREN
    (66) turnright -> . TURNRIGHT LPAREN express COMMA express RPAREN
    (67) servo -> . SERVO LPAREN express RPAREN
    (68) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (69) display -> . DISPLAY LPAREN express RPAREN
    (70) distance -> . DISTANCE LPAREN RPAREN
    (71) stop -> . STOP LPAREN RPAREN
    (72) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (74) return -> . RETURN LPAREN express RPAREN
    (48) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 74
    ID              shift and go to state 75
    CIN             shift and go to state 77
    COUT            shift and go to state 78
    DELAY           shift and go to state 79
    FORWARD         shift and go to state 80
    BACKWARD        shift and go to state 81
    TURNLEFT        shift and go to state 82
    TURNRIGHT       shift and go to state 83
    SERVO           shift and go to state 84
    LIGHTS          shift and go to state 85
    DISPLAY         shift and go to state 86
    DISTANCE        shift and go to state 87
    STOP            shift and go to state 88
    WHILE           shift and go to state 89
    RETURN          shift and go to state 90

    block                          shift and go to state 245
    statute                        shift and go to state 55
    empty                          shift and go to state 56
    cond                           shift and go to state 57
    assign                         shift and go to state 58
    call                           shift and go to state 59
    cin                            shift and go to state 60
    cout                           shift and go to state 61
    delay                          shift and go to state 62
    forward                        shift and go to state 63
    backward                       shift and go to state 64
    turnleft                       shift and go to state 65
    turnright                      shift and go to state 66
    servo                          shift and go to state 67
    lights                         shift and go to state 68
    display                        shift and go to state 69
    distance                       shift and go to state 70
    stop                           shift and go to state 71
    while                          shift and go to state 72
    return                         shift and go to state 73
    era                            shift and go to state 76

state 244

    (43) gotoelse -> empty .

    IF              reduce using rule 43 (gotoelse -> empty .)
    ID              reduce using rule 43 (gotoelse -> empty .)
    CIN             reduce using rule 43 (gotoelse -> empty .)
    COUT            reduce using rule 43 (gotoelse -> empty .)
    DELAY           reduce using rule 43 (gotoelse -> empty .)
    FORWARD         reduce using rule 43 (gotoelse -> empty .)
    BACKWARD        reduce using rule 43 (gotoelse -> empty .)
    TURNLEFT        reduce using rule 43 (gotoelse -> empty .)
    TURNRIGHT       reduce using rule 43 (gotoelse -> empty .)
    SERVO           reduce using rule 43 (gotoelse -> empty .)
    LIGHTS          reduce using rule 43 (gotoelse -> empty .)
    DISPLAY         reduce using rule 43 (gotoelse -> empty .)
    DISTANCE        reduce using rule 43 (gotoelse -> empty .)
    STOP            reduce using rule 43 (gotoelse -> empty .)
    WHILE           reduce using rule 43 (gotoelse -> empty .)
    RETURN          reduce using rule 43 (gotoelse -> empty .)
    RCURLY          reduce using rule 43 (gotoelse -> empty .)


state 245

    (41) else -> ELSE LCURLY gotoelse block . RCURLY else

    RCURLY          shift and go to state 246


state 246

    (41) else -> ELSE LCURLY gotoelse block RCURLY . else
    (41) else -> . ELSE LCURLY gotoelse block RCURLY else
    (42) else -> . empty
    (113) empty -> .

    ELSE            shift and go to state 240
    SEMICOLON       reduce using rule 113 (empty -> .)

    else                           shift and go to state 247
    empty                          shift and go to state 241

state 247

    (41) else -> ELSE LCURLY gotoelse block RCURLY else .

    SEMICOLON       reduce using rule 41 (else -> ELSE LCURLY gotoelse block RCURLY else .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 35 resolved as shift
WARNING: shift/reduce conflict for INT in state 35 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 35 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 35 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 35 resolved as shift
WARNING: shift/reduce conflict for VOID in state 35 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 41 resolved as shift
WARNING: shift/reduce conflict for INT in state 41 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 41 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 41 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 41 resolved as shift
WARNING: shift/reduce conflict for VOID in state 41 resolved as shift
WARNING: shift/reduce conflict for INT in state 42 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 42 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 42 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 42 resolved as shift
WARNING: shift/reduce conflict for VOID in state 42 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 49 resolved as shift
WARNING: shift/reduce conflict for INT in state 49 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 49 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 49 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 49 resolved as shift
WARNING: shift/reduce conflict for VOID in state 49 resolved as shift
WARNING: reduce/reduce conflict in state 43 resolved using rule (paramsblock -> empty)
WARNING: rejected rule (params -> empty) in state 43
