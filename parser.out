Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON
Rule 2     gotomain -> empty
Rule 3     main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY
Rule 4     main1 -> empty
Rule 5     setmain -> empty
Rule 6     funcsblock -> funcs funcsblock
Rule 7     funcsblock -> empty
Rule 8     funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
Rule 9     funcs1 -> empty
Rule 10    setscope -> ID
Rule 11    varsblock -> vars varsblock
Rule 12    varsblock -> empty
Rule 13    vars -> VARDEF type ID dimvar SEMICOLON
Rule 14    dimvar -> LBRACKET express RBRACKET
Rule 15    dimvar -> empty
Rule 16    paramsblock -> params paramsblock
Rule 17    paramsblock -> COMMA params paramsblock
Rule 18    paramsblock -> empty
Rule 19    params -> type ID
Rule 20    params -> empty
Rule 21    block -> statute SEMICOLON block
Rule 22    block -> empty
Rule 23    statute -> cond
Rule 24    statute -> assign
Rule 25    statute -> call
Rule 26    statute -> cin
Rule 27    statute -> cout
Rule 28    statute -> delay
Rule 29    statute -> forward
Rule 30    statute -> backward
Rule 31    statute -> turnleft
Rule 32    statute -> turnright
Rule 33    statute -> servo
Rule 34    statute -> lights
Rule 35    statute -> distance
Rule 36    statute -> stop
Rule 37    statute -> while
Rule 38    statute -> return
Rule 39    cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
Rule 40    gotoif -> empty
Rule 41    else -> ELSE LCURLY gotoelse block RCURLY else
Rule 42    else -> empty
Rule 43    gotoelse -> empty
Rule 44    assign -> ID array ASSIGN express
Rule 45    call -> era LPAREN insertfloor paramcall RPAREN endfloor
Rule 46    era -> ID
Rule 47    paramcall -> express paramcall1
Rule 48    paramcall -> empty
Rule 49    paramcall1 -> COMMA paramcall
Rule 50    paramcall1 -> empty
Rule 51    cin -> CIN cin1
Rule 52    cin1 -> cin2
Rule 53    cin1 -> cin3
Rule 54    cin2 -> LPAREN ID RPAREN
Rule 55    cin3 -> LBRACKET CTE_INT RBRACKET LPAREN cin4 RPAREN
Rule 56    cin4 -> COMMA ID cin4
Rule 57    cin4 -> empty
Rule 58    cout -> COUT LPAREN express cout1 RPAREN
Rule 59    cout1 -> COMMA express cout1
Rule 60    cout1 -> empty
Rule 61    delay -> DELAY LPAREN express RPAREN
Rule 62    forward -> FORWARD LPAREN express RPAREN
Rule 63    backward -> BACKWARD LPAREN express RPAREN
Rule 64    turnleft -> TURNLEFT LPAREN express RPAREN
Rule 65    turnright -> TURNRIGHT LPAREN express RPAREN
Rule 66    servo -> SERVO LPAREN express RPAREN
Rule 67    lights -> LIGHTS LPAREN express COMMA express RPAREN
Rule 68    distance -> DISTANCE LPAREN RPAREN
Rule 69    stop -> STOP LPAREN RPAREN
Rule 70    while -> WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
Rule 71    while1 -> empty
Rule 72    return -> RETURN LPAREN express RPAREN
Rule 73    type -> INT
Rule 74    type -> FLOAT
Rule 75    type -> BOOL
Rule 76    type -> CHAR
Rule 77    type -> VOID
Rule 78    constant -> ID array
Rule 79    constant -> CTE_INT
Rule 80    constant -> CTE_FLOAT
Rule 81    constant -> CTE_CHAR
Rule 82    constant -> CTE_BOOL
Rule 83    array -> LBRACKET insertfloor express RBRACKET endfloor
Rule 84    array -> empty
Rule 85    express -> relational express1
Rule 86    express1 -> andor express
Rule 87    express1 -> empty
Rule 88    andor -> AND
Rule 89    andor -> OR
Rule 90    relational -> exp relational1
Rule 91    relational -> NOT
Rule 92    relational1 -> compare exp
Rule 93    relational1 -> empty
Rule 94    compare -> LESSTHAN
Rule 95    compare -> GREATERTHAN
Rule 96    compare -> EQUALS
Rule 97    compare -> NOTEQUALS
Rule 98    exp -> term exp1
Rule 99    exp1 -> plusminus exp
Rule 100   exp1 -> empty
Rule 101   plusminus -> PLUS
Rule 102   plusminus -> MINUS
Rule 103   term -> factor term1
Rule 104   term1 -> multidivi term
Rule 105   term1 -> empty
Rule 106   multidivi -> MULTI
Rule 107   multidivi -> DIVI
Rule 108   factor -> LPAREN insertfloor express RPAREN endfloor
Rule 109   factor -> constant
Rule 110   factor -> call
Rule 111   insertfloor -> empty
Rule 112   endfloor -> empty
Rule 113   empty -> <empty>

Terminals, with rules where they appear

AND                  : 88
ASSIGN               : 44
BACKWARD             : 63
BOOL                 : 75
CHAR                 : 76
CIN                  : 51
COMMA                : 17 49 56 59 67
COUT                 : 58
CTE_BOOL             : 82
CTE_CHAR             : 81
CTE_FLOAT            : 80
CTE_INT              : 55 79
DELAY                : 61
DISTANCE             : 68
DIVI                 : 107
ELSE                 : 41
EQUALS               : 96
FIN                  : 1
FLOAT                : 74
FORWARD              : 62
FUNCDEF              : 8
GREATERTHAN          : 95
ID                   : 10 13 19 44 46 54 56 78
IF                   : 39
INT                  : 73
LBRACKET             : 14 55 83
LCURLY               : 3 8 39 41 70
LESSTHAN             : 94
LIGHTS               : 67
LPAREN               : 3 8 39 45 54 55 58 61 62 63 64 65 66 67 68 69 70 72 108
MAIN                 : 3
MINUS                : 102
MULTI                : 106
NOT                  : 91
NOTEQUALS            : 97
OR                   : 89
PLUS                 : 101
PROGRAM              : 1
RBRACKET             : 14 55 83
RCURLY               : 3 8 39 41 70
RETURN               : 72
RPAREN               : 3 8 39 45 54 55 58 61 62 63 64 65 66 67 68 69 70 72 108
SEMICOLON            : 1 13 21
SERVO                : 66
STOP                 : 69
TURNLEFT             : 64
TURNRIGHT            : 65
VARDEF               : 13
VOID                 : 77
WHILE                : 70
error                : 

Nonterminals, with rules where they appear

andor                : 86
array                : 44 78
assign               : 24
backward             : 30
block                : 3 8 21 39 41 70
call                 : 25 110
cin                  : 26
cin1                 : 51
cin2                 : 52
cin3                 : 53
cin4                 : 55 56
compare              : 92
cond                 : 23
constant             : 109
cout                 : 27
cout1                : 58 59
delay                : 28
dimvar               : 13
distance             : 35
else                 : 39 41
empty                : 2 4 5 7 9 12 15 18 20 22 40 42 43 48 50 57 60 71 84 87 93 100 105 111 112
endfloor             : 45 83 108
era                  : 45
exp                  : 90 92 99
exp1                 : 98
express              : 14 39 44 47 58 59 61 62 63 64 65 66 67 67 70 72 83 86 108
express1             : 85
factor               : 103
forward              : 29
funcs                : 6
funcs1               : 8
funcsblock           : 1 6
gotoelse             : 41
gotoif               : 39
gotomain             : 1
insertfloor          : 45 83 108
lights               : 34
main                 : 1
main1                : 3
multidivi            : 104
paramcall            : 45 49
paramcall1           : 47
params               : 16 17
paramsblock          : 8 16 17
plusminus            : 99
program              : 0
relational           : 85
relational1          : 90
return               : 38
servo                : 33
setmain              : 3
setscope             : 8
statute              : 21
stop                 : 36
term                 : 98 104
term1                : 103
turnleft             : 31
turnright            : 32
type                 : 8 13 19
vars                 : 11
varsblock            : 1 3 8 11
while                : 37
while1               : 70

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . gotomain varsblock funcsblock main FIN SEMICOLON
    (2) gotomain -> . empty
    (113) empty -> .

    VARDEF          reduce using rule 113 (empty -> .)
    FUNCDEF         reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)

    gotomain                       shift and go to state 3
    empty                          shift and go to state 4

state 3

    (1) program -> PROGRAM gotomain . varsblock funcsblock main FIN SEMICOLON
    (11) varsblock -> . vars varsblock
    (12) varsblock -> . empty
    (13) vars -> . VARDEF type ID dimvar SEMICOLON
    (113) empty -> .

    VARDEF          shift and go to state 8
    FUNCDEF         reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)

    varsblock                      shift and go to state 5
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 4

    (2) gotomain -> empty .

    VARDEF          reduce using rule 2 (gotomain -> empty .)
    FUNCDEF         reduce using rule 2 (gotomain -> empty .)
    MAIN            reduce using rule 2 (gotomain -> empty .)


state 5

    (1) program -> PROGRAM gotomain varsblock . funcsblock main FIN SEMICOLON
    (6) funcsblock -> . funcs funcsblock
    (7) funcsblock -> . empty
    (8) funcs -> . FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (113) empty -> .

    FUNCDEF         shift and go to state 12
    MAIN            reduce using rule 113 (empty -> .)

    funcsblock                     shift and go to state 9
    funcs                          shift and go to state 10
    empty                          shift and go to state 11

state 6

    (11) varsblock -> vars . varsblock
    (11) varsblock -> . vars varsblock
    (12) varsblock -> . empty
    (13) vars -> . VARDEF type ID dimvar SEMICOLON
    (113) empty -> .

    VARDEF          shift and go to state 8
    FUNCDEF         reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    vars                           shift and go to state 6
    varsblock                      shift and go to state 13
    empty                          shift and go to state 7

state 7

    (12) varsblock -> empty .

    FUNCDEF         reduce using rule 12 (varsblock -> empty .)
    MAIN            reduce using rule 12 (varsblock -> empty .)
    IF              reduce using rule 12 (varsblock -> empty .)
    ID              reduce using rule 12 (varsblock -> empty .)
    CIN             reduce using rule 12 (varsblock -> empty .)
    COUT            reduce using rule 12 (varsblock -> empty .)
    DELAY           reduce using rule 12 (varsblock -> empty .)
    FORWARD         reduce using rule 12 (varsblock -> empty .)
    BACKWARD        reduce using rule 12 (varsblock -> empty .)
    TURNLEFT        reduce using rule 12 (varsblock -> empty .)
    TURNRIGHT       reduce using rule 12 (varsblock -> empty .)
    SERVO           reduce using rule 12 (varsblock -> empty .)
    LIGHTS          reduce using rule 12 (varsblock -> empty .)
    DISTANCE        reduce using rule 12 (varsblock -> empty .)
    STOP            reduce using rule 12 (varsblock -> empty .)
    WHILE           reduce using rule 12 (varsblock -> empty .)
    RETURN          reduce using rule 12 (varsblock -> empty .)
    RCURLY          reduce using rule 12 (varsblock -> empty .)


state 8

    (13) vars -> VARDEF . type ID dimvar SEMICOLON
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . CHAR
    (77) type -> . VOID

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

    type                           shift and go to state 14

state 9

    (1) program -> PROGRAM gotomain varsblock funcsblock . main FIN SEMICOLON
    (3) main -> . MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY

    MAIN            shift and go to state 21

    main                           shift and go to state 20

state 10

    (6) funcsblock -> funcs . funcsblock
    (6) funcsblock -> . funcs funcsblock
    (7) funcsblock -> . empty
    (8) funcs -> . FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (113) empty -> .

    FUNCDEF         shift and go to state 12
    MAIN            reduce using rule 113 (empty -> .)

    funcs                          shift and go to state 10
    funcsblock                     shift and go to state 22
    empty                          shift and go to state 11

state 11

    (7) funcsblock -> empty .

    MAIN            reduce using rule 7 (funcsblock -> empty .)


state 12

    (8) funcs -> FUNCDEF . type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . CHAR
    (77) type -> . VOID

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

    type                           shift and go to state 23

state 13

    (11) varsblock -> vars varsblock .

    FUNCDEF         reduce using rule 11 (varsblock -> vars varsblock .)
    MAIN            reduce using rule 11 (varsblock -> vars varsblock .)
    IF              reduce using rule 11 (varsblock -> vars varsblock .)
    ID              reduce using rule 11 (varsblock -> vars varsblock .)
    CIN             reduce using rule 11 (varsblock -> vars varsblock .)
    COUT            reduce using rule 11 (varsblock -> vars varsblock .)
    DELAY           reduce using rule 11 (varsblock -> vars varsblock .)
    FORWARD         reduce using rule 11 (varsblock -> vars varsblock .)
    BACKWARD        reduce using rule 11 (varsblock -> vars varsblock .)
    TURNLEFT        reduce using rule 11 (varsblock -> vars varsblock .)
    TURNRIGHT       reduce using rule 11 (varsblock -> vars varsblock .)
    SERVO           reduce using rule 11 (varsblock -> vars varsblock .)
    LIGHTS          reduce using rule 11 (varsblock -> vars varsblock .)
    DISTANCE        reduce using rule 11 (varsblock -> vars varsblock .)
    STOP            reduce using rule 11 (varsblock -> vars varsblock .)
    WHILE           reduce using rule 11 (varsblock -> vars varsblock .)
    RETURN          reduce using rule 11 (varsblock -> vars varsblock .)
    RCURLY          reduce using rule 11 (varsblock -> vars varsblock .)


state 14

    (13) vars -> VARDEF type . ID dimvar SEMICOLON

    ID              shift and go to state 24


state 15

    (73) type -> INT .

    ID              reduce using rule 73 (type -> INT .)


state 16

    (74) type -> FLOAT .

    ID              reduce using rule 74 (type -> FLOAT .)


state 17

    (75) type -> BOOL .

    ID              reduce using rule 75 (type -> BOOL .)


state 18

    (76) type -> CHAR .

    ID              reduce using rule 76 (type -> CHAR .)


state 19

    (77) type -> VOID .

    ID              reduce using rule 77 (type -> VOID .)


state 20

    (1) program -> PROGRAM gotomain varsblock funcsblock main . FIN SEMICOLON

    FIN             shift and go to state 25


state 21

    (3) main -> MAIN . setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY
    (5) setmain -> . empty
    (113) empty -> .

    LPAREN          reduce using rule 113 (empty -> .)

    setmain                        shift and go to state 26
    empty                          shift and go to state 27

state 22

    (6) funcsblock -> funcs funcsblock .

    MAIN            reduce using rule 6 (funcsblock -> funcs funcsblock .)


state 23

    (8) funcs -> FUNCDEF type . setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (10) setscope -> . ID

    ID              shift and go to state 29

    setscope                       shift and go to state 28

state 24

    (13) vars -> VARDEF type ID . dimvar SEMICOLON
    (14) dimvar -> . LBRACKET express RBRACKET
    (15) dimvar -> . empty
    (113) empty -> .

    LBRACKET        shift and go to state 31
    SEMICOLON       reduce using rule 113 (empty -> .)

    dimvar                         shift and go to state 30
    empty                          shift and go to state 32

state 25

    (1) program -> PROGRAM gotomain varsblock funcsblock main FIN . SEMICOLON

    SEMICOLON       shift and go to state 33


state 26

    (3) main -> MAIN setmain . LPAREN RPAREN LCURLY varsblock main1 block RCURLY

    LPAREN          shift and go to state 34


state 27

    (5) setmain -> empty .

    LPAREN          reduce using rule 5 (setmain -> empty .)


state 28

    (8) funcs -> FUNCDEF type setscope . LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY

    LPAREN          shift and go to state 35


state 29

    (10) setscope -> ID .

    LPAREN          reduce using rule 10 (setscope -> ID .)


state 30

    (13) vars -> VARDEF type ID dimvar . SEMICOLON

    SEMICOLON       shift and go to state 36


state 31

    (14) dimvar -> LBRACKET . express RBRACKET
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 37
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 32

    (15) dimvar -> empty .

    SEMICOLON       reduce using rule 15 (dimvar -> empty .)


state 33

    (1) program -> PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON .

    $end            reduce using rule 1 (program -> PROGRAM gotomain varsblock funcsblock main FIN SEMICOLON .)


state 34

    (3) main -> MAIN setmain LPAREN . RPAREN LCURLY varsblock main1 block RCURLY

    RPAREN          shift and go to state 52


state 35

    (8) funcs -> FUNCDEF type setscope LPAREN . paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY
    (16) paramsblock -> . params paramsblock
    (17) paramsblock -> . COMMA params paramsblock
    (18) paramsblock -> . empty
    (19) params -> . type ID
    (20) params -> . empty
    (113) empty -> .
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . CHAR
    (77) type -> . VOID

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMA           shift and go to state 56
    RPAREN          reduce using rule 113 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

  ! COMMA           [ reduce using rule 113 (empty -> .) ]
  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! VOID            [ reduce using rule 113 (empty -> .) ]

    type                           shift and go to state 53
    paramsblock                    shift and go to state 54
    params                         shift and go to state 55
    empty                          shift and go to state 57

state 36

    (13) vars -> VARDEF type ID dimvar SEMICOLON .

    VARDEF          reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    FUNCDEF         reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    MAIN            reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    IF              reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    ID              reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    CIN             reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    COUT            reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    DELAY           reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    FORWARD         reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    BACKWARD        reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    TURNLEFT        reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    TURNRIGHT       reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    SERVO           reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    LIGHTS          reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    DISTANCE        reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    STOP            reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    WHILE           reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    RETURN          reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)
    RCURLY          reduce using rule 13 (vars -> VARDEF type ID dimvar SEMICOLON .)


state 37

    (14) dimvar -> LBRACKET express . RBRACKET

    RBRACKET        shift and go to state 58


state 38

    (85) express -> relational . express1
    (86) express1 -> . andor express
    (87) express1 -> . empty
    (88) andor -> . AND
    (89) andor -> . OR
    (113) empty -> .

    AND             shift and go to state 62
    OR              shift and go to state 63
    RBRACKET        reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    express1                       shift and go to state 59
    andor                          shift and go to state 60
    empty                          shift and go to state 61

state 39

    (90) relational -> exp . relational1
    (92) relational1 -> . compare exp
    (93) relational1 -> . empty
    (94) compare -> . LESSTHAN
    (95) compare -> . GREATERTHAN
    (96) compare -> . EQUALS
    (97) compare -> . NOTEQUALS
    (113) empty -> .

    LESSTHAN        shift and go to state 67
    GREATERTHAN     shift and go to state 68
    EQUALS          shift and go to state 69
    NOTEQUALS       shift and go to state 70
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    relational1                    shift and go to state 64
    compare                        shift and go to state 65
    empty                          shift and go to state 66

state 40

    (91) relational -> NOT .

    AND             reduce using rule 91 (relational -> NOT .)
    OR              reduce using rule 91 (relational -> NOT .)
    RBRACKET        reduce using rule 91 (relational -> NOT .)
    RPAREN          reduce using rule 91 (relational -> NOT .)
    COMMA           reduce using rule 91 (relational -> NOT .)
    SEMICOLON       reduce using rule 91 (relational -> NOT .)


state 41

    (98) exp -> term . exp1
    (99) exp1 -> . plusminus exp
    (100) exp1 -> . empty
    (101) plusminus -> . PLUS
    (102) plusminus -> . MINUS
    (113) empty -> .

    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    LESSTHAN        reduce using rule 113 (empty -> .)
    GREATERTHAN     reduce using rule 113 (empty -> .)
    EQUALS          reduce using rule 113 (empty -> .)
    NOTEQUALS       reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    exp1                           shift and go to state 71
    plusminus                      shift and go to state 72
    empty                          shift and go to state 73

state 42

    (103) term -> factor . term1
    (104) term1 -> . multidivi term
    (105) term1 -> . empty
    (106) multidivi -> . MULTI
    (107) multidivi -> . DIVI
    (113) empty -> .

    MULTI           shift and go to state 79
    DIVI            shift and go to state 80
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    GREATERTHAN     reduce using rule 113 (empty -> .)
    EQUALS          reduce using rule 113 (empty -> .)
    NOTEQUALS       reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    term1                          shift and go to state 76
    multidivi                      shift and go to state 77
    empty                          shift and go to state 78

state 43

    (108) factor -> LPAREN . insertfloor express RPAREN endfloor
    (111) insertfloor -> . empty
    (113) empty -> .

    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    insertfloor                    shift and go to state 81
    empty                          shift and go to state 82

state 44

    (109) factor -> constant .

    MULTI           reduce using rule 109 (factor -> constant .)
    DIVI            reduce using rule 109 (factor -> constant .)
    PLUS            reduce using rule 109 (factor -> constant .)
    MINUS           reduce using rule 109 (factor -> constant .)
    LESSTHAN        reduce using rule 109 (factor -> constant .)
    GREATERTHAN     reduce using rule 109 (factor -> constant .)
    EQUALS          reduce using rule 109 (factor -> constant .)
    NOTEQUALS       reduce using rule 109 (factor -> constant .)
    AND             reduce using rule 109 (factor -> constant .)
    OR              reduce using rule 109 (factor -> constant .)
    RBRACKET        reduce using rule 109 (factor -> constant .)
    RPAREN          reduce using rule 109 (factor -> constant .)
    COMMA           reduce using rule 109 (factor -> constant .)
    SEMICOLON       reduce using rule 109 (factor -> constant .)


state 45

    (110) factor -> call .

    MULTI           reduce using rule 110 (factor -> call .)
    DIVI            reduce using rule 110 (factor -> call .)
    PLUS            reduce using rule 110 (factor -> call .)
    MINUS           reduce using rule 110 (factor -> call .)
    LESSTHAN        reduce using rule 110 (factor -> call .)
    GREATERTHAN     reduce using rule 110 (factor -> call .)
    EQUALS          reduce using rule 110 (factor -> call .)
    NOTEQUALS       reduce using rule 110 (factor -> call .)
    AND             reduce using rule 110 (factor -> call .)
    OR              reduce using rule 110 (factor -> call .)
    RBRACKET        reduce using rule 110 (factor -> call .)
    RPAREN          reduce using rule 110 (factor -> call .)
    COMMA           reduce using rule 110 (factor -> call .)
    SEMICOLON       reduce using rule 110 (factor -> call .)


state 46

    (78) constant -> ID . array
    (46) era -> ID .
    (83) array -> . LBRACKET insertfloor express RBRACKET endfloor
    (84) array -> . empty
    (113) empty -> .

    LPAREN          reduce using rule 46 (era -> ID .)
    LBRACKET        shift and go to state 84
    MULTI           reduce using rule 113 (empty -> .)
    DIVI            reduce using rule 113 (empty -> .)
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    GREATERTHAN     reduce using rule 113 (empty -> .)
    EQUALS          reduce using rule 113 (empty -> .)
    NOTEQUALS       reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    array                          shift and go to state 83
    empty                          shift and go to state 85

state 47

    (79) constant -> CTE_INT .

    MULTI           reduce using rule 79 (constant -> CTE_INT .)
    DIVI            reduce using rule 79 (constant -> CTE_INT .)
    PLUS            reduce using rule 79 (constant -> CTE_INT .)
    MINUS           reduce using rule 79 (constant -> CTE_INT .)
    LESSTHAN        reduce using rule 79 (constant -> CTE_INT .)
    GREATERTHAN     reduce using rule 79 (constant -> CTE_INT .)
    EQUALS          reduce using rule 79 (constant -> CTE_INT .)
    NOTEQUALS       reduce using rule 79 (constant -> CTE_INT .)
    AND             reduce using rule 79 (constant -> CTE_INT .)
    OR              reduce using rule 79 (constant -> CTE_INT .)
    RBRACKET        reduce using rule 79 (constant -> CTE_INT .)
    RPAREN          reduce using rule 79 (constant -> CTE_INT .)
    COMMA           reduce using rule 79 (constant -> CTE_INT .)
    SEMICOLON       reduce using rule 79 (constant -> CTE_INT .)


state 48

    (80) constant -> CTE_FLOAT .

    MULTI           reduce using rule 80 (constant -> CTE_FLOAT .)
    DIVI            reduce using rule 80 (constant -> CTE_FLOAT .)
    PLUS            reduce using rule 80 (constant -> CTE_FLOAT .)
    MINUS           reduce using rule 80 (constant -> CTE_FLOAT .)
    LESSTHAN        reduce using rule 80 (constant -> CTE_FLOAT .)
    GREATERTHAN     reduce using rule 80 (constant -> CTE_FLOAT .)
    EQUALS          reduce using rule 80 (constant -> CTE_FLOAT .)
    NOTEQUALS       reduce using rule 80 (constant -> CTE_FLOAT .)
    AND             reduce using rule 80 (constant -> CTE_FLOAT .)
    OR              reduce using rule 80 (constant -> CTE_FLOAT .)
    RBRACKET        reduce using rule 80 (constant -> CTE_FLOAT .)
    RPAREN          reduce using rule 80 (constant -> CTE_FLOAT .)
    COMMA           reduce using rule 80 (constant -> CTE_FLOAT .)
    SEMICOLON       reduce using rule 80 (constant -> CTE_FLOAT .)


state 49

    (81) constant -> CTE_CHAR .

    MULTI           reduce using rule 81 (constant -> CTE_CHAR .)
    DIVI            reduce using rule 81 (constant -> CTE_CHAR .)
    PLUS            reduce using rule 81 (constant -> CTE_CHAR .)
    MINUS           reduce using rule 81 (constant -> CTE_CHAR .)
    LESSTHAN        reduce using rule 81 (constant -> CTE_CHAR .)
    GREATERTHAN     reduce using rule 81 (constant -> CTE_CHAR .)
    EQUALS          reduce using rule 81 (constant -> CTE_CHAR .)
    NOTEQUALS       reduce using rule 81 (constant -> CTE_CHAR .)
    AND             reduce using rule 81 (constant -> CTE_CHAR .)
    OR              reduce using rule 81 (constant -> CTE_CHAR .)
    RBRACKET        reduce using rule 81 (constant -> CTE_CHAR .)
    RPAREN          reduce using rule 81 (constant -> CTE_CHAR .)
    COMMA           reduce using rule 81 (constant -> CTE_CHAR .)
    SEMICOLON       reduce using rule 81 (constant -> CTE_CHAR .)


state 50

    (82) constant -> CTE_BOOL .

    MULTI           reduce using rule 82 (constant -> CTE_BOOL .)
    DIVI            reduce using rule 82 (constant -> CTE_BOOL .)
    PLUS            reduce using rule 82 (constant -> CTE_BOOL .)
    MINUS           reduce using rule 82 (constant -> CTE_BOOL .)
    LESSTHAN        reduce using rule 82 (constant -> CTE_BOOL .)
    GREATERTHAN     reduce using rule 82 (constant -> CTE_BOOL .)
    EQUALS          reduce using rule 82 (constant -> CTE_BOOL .)
    NOTEQUALS       reduce using rule 82 (constant -> CTE_BOOL .)
    AND             reduce using rule 82 (constant -> CTE_BOOL .)
    OR              reduce using rule 82 (constant -> CTE_BOOL .)
    RBRACKET        reduce using rule 82 (constant -> CTE_BOOL .)
    RPAREN          reduce using rule 82 (constant -> CTE_BOOL .)
    COMMA           reduce using rule 82 (constant -> CTE_BOOL .)
    SEMICOLON       reduce using rule 82 (constant -> CTE_BOOL .)


state 51

    (45) call -> era . LPAREN insertfloor paramcall RPAREN endfloor

    LPAREN          shift and go to state 86


state 52

    (3) main -> MAIN setmain LPAREN RPAREN . LCURLY varsblock main1 block RCURLY

    LCURLY          shift and go to state 87


state 53

    (19) params -> type . ID

    ID              shift and go to state 88


state 54

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock . RPAREN LCURLY varsblock funcs1 block RCURLY

    RPAREN          shift and go to state 89


state 55

    (16) paramsblock -> params . paramsblock
    (16) paramsblock -> . params paramsblock
    (17) paramsblock -> . COMMA params paramsblock
    (18) paramsblock -> . empty
    (19) params -> . type ID
    (20) params -> . empty
    (113) empty -> .
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . CHAR
    (77) type -> . VOID

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMA           shift and go to state 56
    RPAREN          reduce using rule 113 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

  ! COMMA           [ reduce using rule 113 (empty -> .) ]
  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! VOID            [ reduce using rule 113 (empty -> .) ]

    params                         shift and go to state 55
    paramsblock                    shift and go to state 90
    empty                          shift and go to state 57
    type                           shift and go to state 53

state 56

    (17) paramsblock -> COMMA . params paramsblock
    (19) params -> . type ID
    (20) params -> . empty
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . CHAR
    (77) type -> . VOID
    (113) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19
    COMMA           reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! VOID            [ reduce using rule 113 (empty -> .) ]

    params                         shift and go to state 91
    type                           shift and go to state 53
    empty                          shift and go to state 92

state 57

    (18) paramsblock -> empty .
    (20) params -> empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 18 (paramsblock -> empty .)
    RPAREN          reduce using rule 18 (paramsblock -> empty .)
    COMMA           reduce using rule 20 (params -> empty .)
    INT             reduce using rule 20 (params -> empty .)
    FLOAT           reduce using rule 20 (params -> empty .)
    BOOL            reduce using rule 20 (params -> empty .)
    CHAR            reduce using rule 20 (params -> empty .)
    VOID            reduce using rule 20 (params -> empty .)

  ! RPAREN          [ reduce using rule 20 (params -> empty .) ]


state 58

    (14) dimvar -> LBRACKET express RBRACKET .

    SEMICOLON       reduce using rule 14 (dimvar -> LBRACKET express RBRACKET .)


state 59

    (85) express -> relational express1 .

    RBRACKET        reduce using rule 85 (express -> relational express1 .)
    RPAREN          reduce using rule 85 (express -> relational express1 .)
    COMMA           reduce using rule 85 (express -> relational express1 .)
    SEMICOLON       reduce using rule 85 (express -> relational express1 .)


state 60

    (86) express1 -> andor . express
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 93
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 61

    (87) express1 -> empty .

    RBRACKET        reduce using rule 87 (express1 -> empty .)
    RPAREN          reduce using rule 87 (express1 -> empty .)
    COMMA           reduce using rule 87 (express1 -> empty .)
    SEMICOLON       reduce using rule 87 (express1 -> empty .)


state 62

    (88) andor -> AND .

    NOT             reduce using rule 88 (andor -> AND .)
    LPAREN          reduce using rule 88 (andor -> AND .)
    ID              reduce using rule 88 (andor -> AND .)
    CTE_INT         reduce using rule 88 (andor -> AND .)
    CTE_FLOAT       reduce using rule 88 (andor -> AND .)
    CTE_CHAR        reduce using rule 88 (andor -> AND .)
    CTE_BOOL        reduce using rule 88 (andor -> AND .)


state 63

    (89) andor -> OR .

    NOT             reduce using rule 89 (andor -> OR .)
    LPAREN          reduce using rule 89 (andor -> OR .)
    ID              reduce using rule 89 (andor -> OR .)
    CTE_INT         reduce using rule 89 (andor -> OR .)
    CTE_FLOAT       reduce using rule 89 (andor -> OR .)
    CTE_CHAR        reduce using rule 89 (andor -> OR .)
    CTE_BOOL        reduce using rule 89 (andor -> OR .)


state 64

    (90) relational -> exp relational1 .

    AND             reduce using rule 90 (relational -> exp relational1 .)
    OR              reduce using rule 90 (relational -> exp relational1 .)
    RBRACKET        reduce using rule 90 (relational -> exp relational1 .)
    RPAREN          reduce using rule 90 (relational -> exp relational1 .)
    COMMA           reduce using rule 90 (relational -> exp relational1 .)
    SEMICOLON       reduce using rule 90 (relational -> exp relational1 .)


state 65

    (92) relational1 -> compare . exp
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    exp                            shift and go to state 94
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 66

    (93) relational1 -> empty .

    AND             reduce using rule 93 (relational1 -> empty .)
    OR              reduce using rule 93 (relational1 -> empty .)
    RBRACKET        reduce using rule 93 (relational1 -> empty .)
    RPAREN          reduce using rule 93 (relational1 -> empty .)
    COMMA           reduce using rule 93 (relational1 -> empty .)
    SEMICOLON       reduce using rule 93 (relational1 -> empty .)


state 67

    (94) compare -> LESSTHAN .

    LPAREN          reduce using rule 94 (compare -> LESSTHAN .)
    ID              reduce using rule 94 (compare -> LESSTHAN .)
    CTE_INT         reduce using rule 94 (compare -> LESSTHAN .)
    CTE_FLOAT       reduce using rule 94 (compare -> LESSTHAN .)
    CTE_CHAR        reduce using rule 94 (compare -> LESSTHAN .)
    CTE_BOOL        reduce using rule 94 (compare -> LESSTHAN .)


state 68

    (95) compare -> GREATERTHAN .

    LPAREN          reduce using rule 95 (compare -> GREATERTHAN .)
    ID              reduce using rule 95 (compare -> GREATERTHAN .)
    CTE_INT         reduce using rule 95 (compare -> GREATERTHAN .)
    CTE_FLOAT       reduce using rule 95 (compare -> GREATERTHAN .)
    CTE_CHAR        reduce using rule 95 (compare -> GREATERTHAN .)
    CTE_BOOL        reduce using rule 95 (compare -> GREATERTHAN .)


state 69

    (96) compare -> EQUALS .

    LPAREN          reduce using rule 96 (compare -> EQUALS .)
    ID              reduce using rule 96 (compare -> EQUALS .)
    CTE_INT         reduce using rule 96 (compare -> EQUALS .)
    CTE_FLOAT       reduce using rule 96 (compare -> EQUALS .)
    CTE_CHAR        reduce using rule 96 (compare -> EQUALS .)
    CTE_BOOL        reduce using rule 96 (compare -> EQUALS .)


state 70

    (97) compare -> NOTEQUALS .

    LPAREN          reduce using rule 97 (compare -> NOTEQUALS .)
    ID              reduce using rule 97 (compare -> NOTEQUALS .)
    CTE_INT         reduce using rule 97 (compare -> NOTEQUALS .)
    CTE_FLOAT       reduce using rule 97 (compare -> NOTEQUALS .)
    CTE_CHAR        reduce using rule 97 (compare -> NOTEQUALS .)
    CTE_BOOL        reduce using rule 97 (compare -> NOTEQUALS .)


state 71

    (98) exp -> term exp1 .

    LESSTHAN        reduce using rule 98 (exp -> term exp1 .)
    GREATERTHAN     reduce using rule 98 (exp -> term exp1 .)
    EQUALS          reduce using rule 98 (exp -> term exp1 .)
    NOTEQUALS       reduce using rule 98 (exp -> term exp1 .)
    AND             reduce using rule 98 (exp -> term exp1 .)
    OR              reduce using rule 98 (exp -> term exp1 .)
    RBRACKET        reduce using rule 98 (exp -> term exp1 .)
    RPAREN          reduce using rule 98 (exp -> term exp1 .)
    COMMA           reduce using rule 98 (exp -> term exp1 .)
    SEMICOLON       reduce using rule 98 (exp -> term exp1 .)


state 72

    (99) exp1 -> plusminus . exp
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    exp                            shift and go to state 95
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 73

    (100) exp1 -> empty .

    LESSTHAN        reduce using rule 100 (exp1 -> empty .)
    GREATERTHAN     reduce using rule 100 (exp1 -> empty .)
    EQUALS          reduce using rule 100 (exp1 -> empty .)
    NOTEQUALS       reduce using rule 100 (exp1 -> empty .)
    AND             reduce using rule 100 (exp1 -> empty .)
    OR              reduce using rule 100 (exp1 -> empty .)
    RBRACKET        reduce using rule 100 (exp1 -> empty .)
    RPAREN          reduce using rule 100 (exp1 -> empty .)
    COMMA           reduce using rule 100 (exp1 -> empty .)
    SEMICOLON       reduce using rule 100 (exp1 -> empty .)


state 74

    (101) plusminus -> PLUS .

    LPAREN          reduce using rule 101 (plusminus -> PLUS .)
    ID              reduce using rule 101 (plusminus -> PLUS .)
    CTE_INT         reduce using rule 101 (plusminus -> PLUS .)
    CTE_FLOAT       reduce using rule 101 (plusminus -> PLUS .)
    CTE_CHAR        reduce using rule 101 (plusminus -> PLUS .)
    CTE_BOOL        reduce using rule 101 (plusminus -> PLUS .)


state 75

    (102) plusminus -> MINUS .

    LPAREN          reduce using rule 102 (plusminus -> MINUS .)
    ID              reduce using rule 102 (plusminus -> MINUS .)
    CTE_INT         reduce using rule 102 (plusminus -> MINUS .)
    CTE_FLOAT       reduce using rule 102 (plusminus -> MINUS .)
    CTE_CHAR        reduce using rule 102 (plusminus -> MINUS .)
    CTE_BOOL        reduce using rule 102 (plusminus -> MINUS .)


state 76

    (103) term -> factor term1 .

    PLUS            reduce using rule 103 (term -> factor term1 .)
    MINUS           reduce using rule 103 (term -> factor term1 .)
    LESSTHAN        reduce using rule 103 (term -> factor term1 .)
    GREATERTHAN     reduce using rule 103 (term -> factor term1 .)
    EQUALS          reduce using rule 103 (term -> factor term1 .)
    NOTEQUALS       reduce using rule 103 (term -> factor term1 .)
    AND             reduce using rule 103 (term -> factor term1 .)
    OR              reduce using rule 103 (term -> factor term1 .)
    RBRACKET        reduce using rule 103 (term -> factor term1 .)
    RPAREN          reduce using rule 103 (term -> factor term1 .)
    COMMA           reduce using rule 103 (term -> factor term1 .)
    SEMICOLON       reduce using rule 103 (term -> factor term1 .)


state 77

    (104) term1 -> multidivi . term
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    term                           shift and go to state 96
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 78

    (105) term1 -> empty .

    PLUS            reduce using rule 105 (term1 -> empty .)
    MINUS           reduce using rule 105 (term1 -> empty .)
    LESSTHAN        reduce using rule 105 (term1 -> empty .)
    GREATERTHAN     reduce using rule 105 (term1 -> empty .)
    EQUALS          reduce using rule 105 (term1 -> empty .)
    NOTEQUALS       reduce using rule 105 (term1 -> empty .)
    AND             reduce using rule 105 (term1 -> empty .)
    OR              reduce using rule 105 (term1 -> empty .)
    RBRACKET        reduce using rule 105 (term1 -> empty .)
    RPAREN          reduce using rule 105 (term1 -> empty .)
    COMMA           reduce using rule 105 (term1 -> empty .)
    SEMICOLON       reduce using rule 105 (term1 -> empty .)


state 79

    (106) multidivi -> MULTI .

    LPAREN          reduce using rule 106 (multidivi -> MULTI .)
    ID              reduce using rule 106 (multidivi -> MULTI .)
    CTE_INT         reduce using rule 106 (multidivi -> MULTI .)
    CTE_FLOAT       reduce using rule 106 (multidivi -> MULTI .)
    CTE_CHAR        reduce using rule 106 (multidivi -> MULTI .)
    CTE_BOOL        reduce using rule 106 (multidivi -> MULTI .)


state 80

    (107) multidivi -> DIVI .

    LPAREN          reduce using rule 107 (multidivi -> DIVI .)
    ID              reduce using rule 107 (multidivi -> DIVI .)
    CTE_INT         reduce using rule 107 (multidivi -> DIVI .)
    CTE_FLOAT       reduce using rule 107 (multidivi -> DIVI .)
    CTE_CHAR        reduce using rule 107 (multidivi -> DIVI .)
    CTE_BOOL        reduce using rule 107 (multidivi -> DIVI .)


state 81

    (108) factor -> LPAREN insertfloor . express RPAREN endfloor
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 97
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 82

    (111) insertfloor -> empty .

    NOT             reduce using rule 111 (insertfloor -> empty .)
    LPAREN          reduce using rule 111 (insertfloor -> empty .)
    ID              reduce using rule 111 (insertfloor -> empty .)
    CTE_INT         reduce using rule 111 (insertfloor -> empty .)
    CTE_FLOAT       reduce using rule 111 (insertfloor -> empty .)
    CTE_CHAR        reduce using rule 111 (insertfloor -> empty .)
    CTE_BOOL        reduce using rule 111 (insertfloor -> empty .)
    RPAREN          reduce using rule 111 (insertfloor -> empty .)


state 83

    (78) constant -> ID array .

    MULTI           reduce using rule 78 (constant -> ID array .)
    DIVI            reduce using rule 78 (constant -> ID array .)
    PLUS            reduce using rule 78 (constant -> ID array .)
    MINUS           reduce using rule 78 (constant -> ID array .)
    LESSTHAN        reduce using rule 78 (constant -> ID array .)
    GREATERTHAN     reduce using rule 78 (constant -> ID array .)
    EQUALS          reduce using rule 78 (constant -> ID array .)
    NOTEQUALS       reduce using rule 78 (constant -> ID array .)
    AND             reduce using rule 78 (constant -> ID array .)
    OR              reduce using rule 78 (constant -> ID array .)
    RBRACKET        reduce using rule 78 (constant -> ID array .)
    RPAREN          reduce using rule 78 (constant -> ID array .)
    COMMA           reduce using rule 78 (constant -> ID array .)
    SEMICOLON       reduce using rule 78 (constant -> ID array .)


state 84

    (83) array -> LBRACKET . insertfloor express RBRACKET endfloor
    (111) insertfloor -> . empty
    (113) empty -> .

    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)

    insertfloor                    shift and go to state 98
    empty                          shift and go to state 82

state 85

    (84) array -> empty .

    MULTI           reduce using rule 84 (array -> empty .)
    DIVI            reduce using rule 84 (array -> empty .)
    PLUS            reduce using rule 84 (array -> empty .)
    MINUS           reduce using rule 84 (array -> empty .)
    LESSTHAN        reduce using rule 84 (array -> empty .)
    GREATERTHAN     reduce using rule 84 (array -> empty .)
    EQUALS          reduce using rule 84 (array -> empty .)
    NOTEQUALS       reduce using rule 84 (array -> empty .)
    AND             reduce using rule 84 (array -> empty .)
    OR              reduce using rule 84 (array -> empty .)
    RBRACKET        reduce using rule 84 (array -> empty .)
    RPAREN          reduce using rule 84 (array -> empty .)
    COMMA           reduce using rule 84 (array -> empty .)
    SEMICOLON       reduce using rule 84 (array -> empty .)
    ASSIGN          reduce using rule 84 (array -> empty .)


state 86

    (45) call -> era LPAREN . insertfloor paramcall RPAREN endfloor
    (111) insertfloor -> . empty
    (113) empty -> .

    NOT             reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

    insertfloor                    shift and go to state 99
    empty                          shift and go to state 82

state 87

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY . varsblock main1 block RCURLY
    (11) varsblock -> . vars varsblock
    (12) varsblock -> . empty
    (13) vars -> . VARDEF type ID dimvar SEMICOLON
    (113) empty -> .

    VARDEF          shift and go to state 8
    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    varsblock                      shift and go to state 100
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 88

    (19) params -> type ID .

    COMMA           reduce using rule 19 (params -> type ID .)
    INT             reduce using rule 19 (params -> type ID .)
    FLOAT           reduce using rule 19 (params -> type ID .)
    BOOL            reduce using rule 19 (params -> type ID .)
    CHAR            reduce using rule 19 (params -> type ID .)
    VOID            reduce using rule 19 (params -> type ID .)
    RPAREN          reduce using rule 19 (params -> type ID .)


state 89

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN . LCURLY varsblock funcs1 block RCURLY

    LCURLY          shift and go to state 101


state 90

    (16) paramsblock -> params paramsblock .

    RPAREN          reduce using rule 16 (paramsblock -> params paramsblock .)


state 91

    (17) paramsblock -> COMMA params . paramsblock
    (16) paramsblock -> . params paramsblock
    (17) paramsblock -> . COMMA params paramsblock
    (18) paramsblock -> . empty
    (19) params -> . type ID
    (20) params -> . empty
    (113) empty -> .
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . CHAR
    (77) type -> . VOID

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMA           shift and go to state 56
    RPAREN          reduce using rule 113 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    BOOL            shift and go to state 17
    CHAR            shift and go to state 18
    VOID            shift and go to state 19

  ! COMMA           [ reduce using rule 113 (empty -> .) ]
  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! VOID            [ reduce using rule 113 (empty -> .) ]

    params                         shift and go to state 55
    paramsblock                    shift and go to state 102
    empty                          shift and go to state 57
    type                           shift and go to state 53

state 92

    (20) params -> empty .

    COMMA           reduce using rule 20 (params -> empty .)
    INT             reduce using rule 20 (params -> empty .)
    FLOAT           reduce using rule 20 (params -> empty .)
    BOOL            reduce using rule 20 (params -> empty .)
    CHAR            reduce using rule 20 (params -> empty .)
    VOID            reduce using rule 20 (params -> empty .)
    RPAREN          reduce using rule 20 (params -> empty .)


state 93

    (86) express1 -> andor express .

    RBRACKET        reduce using rule 86 (express1 -> andor express .)
    RPAREN          reduce using rule 86 (express1 -> andor express .)
    COMMA           reduce using rule 86 (express1 -> andor express .)
    SEMICOLON       reduce using rule 86 (express1 -> andor express .)


state 94

    (92) relational1 -> compare exp .

    AND             reduce using rule 92 (relational1 -> compare exp .)
    OR              reduce using rule 92 (relational1 -> compare exp .)
    RBRACKET        reduce using rule 92 (relational1 -> compare exp .)
    RPAREN          reduce using rule 92 (relational1 -> compare exp .)
    COMMA           reduce using rule 92 (relational1 -> compare exp .)
    SEMICOLON       reduce using rule 92 (relational1 -> compare exp .)


state 95

    (99) exp1 -> plusminus exp .

    LESSTHAN        reduce using rule 99 (exp1 -> plusminus exp .)
    GREATERTHAN     reduce using rule 99 (exp1 -> plusminus exp .)
    EQUALS          reduce using rule 99 (exp1 -> plusminus exp .)
    NOTEQUALS       reduce using rule 99 (exp1 -> plusminus exp .)
    AND             reduce using rule 99 (exp1 -> plusminus exp .)
    OR              reduce using rule 99 (exp1 -> plusminus exp .)
    RBRACKET        reduce using rule 99 (exp1 -> plusminus exp .)
    RPAREN          reduce using rule 99 (exp1 -> plusminus exp .)
    COMMA           reduce using rule 99 (exp1 -> plusminus exp .)
    SEMICOLON       reduce using rule 99 (exp1 -> plusminus exp .)


state 96

    (104) term1 -> multidivi term .

    PLUS            reduce using rule 104 (term1 -> multidivi term .)
    MINUS           reduce using rule 104 (term1 -> multidivi term .)
    LESSTHAN        reduce using rule 104 (term1 -> multidivi term .)
    GREATERTHAN     reduce using rule 104 (term1 -> multidivi term .)
    EQUALS          reduce using rule 104 (term1 -> multidivi term .)
    NOTEQUALS       reduce using rule 104 (term1 -> multidivi term .)
    AND             reduce using rule 104 (term1 -> multidivi term .)
    OR              reduce using rule 104 (term1 -> multidivi term .)
    RBRACKET        reduce using rule 104 (term1 -> multidivi term .)
    RPAREN          reduce using rule 104 (term1 -> multidivi term .)
    COMMA           reduce using rule 104 (term1 -> multidivi term .)
    SEMICOLON       reduce using rule 104 (term1 -> multidivi term .)


state 97

    (108) factor -> LPAREN insertfloor express . RPAREN endfloor

    RPAREN          shift and go to state 103


state 98

    (83) array -> LBRACKET insertfloor . express RBRACKET endfloor
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 104
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 99

    (45) call -> era LPAREN insertfloor . paramcall RPAREN endfloor
    (47) paramcall -> . express paramcall1
    (48) paramcall -> . empty
    (85) express -> . relational express1
    (113) empty -> .
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    RPAREN          reduce using rule 113 (empty -> .)
    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    era                            shift and go to state 51
    paramcall                      shift and go to state 105
    express                        shift and go to state 106
    empty                          shift and go to state 107
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45

state 100

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock . main1 block RCURLY
    (4) main1 -> . empty
    (113) empty -> .

    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    main1                          shift and go to state 108
    empty                          shift and go to state 109

state 101

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY . varsblock funcs1 block RCURLY
    (11) varsblock -> . vars varsblock
    (12) varsblock -> . empty
    (13) vars -> . VARDEF type ID dimvar SEMICOLON
    (113) empty -> .

    VARDEF          shift and go to state 8
    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    varsblock                      shift and go to state 110
    vars                           shift and go to state 6
    empty                          shift and go to state 7

state 102

    (17) paramsblock -> COMMA params paramsblock .

    RPAREN          reduce using rule 17 (paramsblock -> COMMA params paramsblock .)


state 103

    (108) factor -> LPAREN insertfloor express RPAREN . endfloor
    (112) endfloor -> . empty
    (113) empty -> .

    MULTI           reduce using rule 113 (empty -> .)
    DIVI            reduce using rule 113 (empty -> .)
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    GREATERTHAN     reduce using rule 113 (empty -> .)
    EQUALS          reduce using rule 113 (empty -> .)
    NOTEQUALS       reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    endfloor                       shift and go to state 111
    empty                          shift and go to state 112

state 104

    (83) array -> LBRACKET insertfloor express . RBRACKET endfloor

    RBRACKET        shift and go to state 113


state 105

    (45) call -> era LPAREN insertfloor paramcall . RPAREN endfloor

    RPAREN          shift and go to state 114


state 106

    (47) paramcall -> express . paramcall1
    (49) paramcall1 -> . COMMA paramcall
    (50) paramcall1 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 116
    RPAREN          reduce using rule 113 (empty -> .)

    paramcall1                     shift and go to state 115
    empty                          shift and go to state 117

state 107

    (48) paramcall -> empty .

    RPAREN          reduce using rule 48 (paramcall -> empty .)


state 108

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 . block RCURLY
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID array ASSIGN express
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (51) cin -> . CIN cin1
    (58) cout -> . COUT LPAREN express cout1 RPAREN
    (61) delay -> . DELAY LPAREN express RPAREN
    (62) forward -> . FORWARD LPAREN express RPAREN
    (63) backward -> . BACKWARD LPAREN express RPAREN
    (64) turnleft -> . TURNLEFT LPAREN express RPAREN
    (65) turnright -> . TURNRIGHT LPAREN express RPAREN
    (66) servo -> . SERVO LPAREN express RPAREN
    (67) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (68) distance -> . DISTANCE LPAREN RPAREN
    (69) stop -> . STOP LPAREN RPAREN
    (70) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (72) return -> . RETURN LPAREN express RPAREN
    (46) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 137
    ID              shift and go to state 138
    CIN             shift and go to state 139
    COUT            shift and go to state 140
    DELAY           shift and go to state 141
    FORWARD         shift and go to state 142
    BACKWARD        shift and go to state 143
    TURNLEFT        shift and go to state 144
    TURNRIGHT       shift and go to state 145
    SERVO           shift and go to state 146
    LIGHTS          shift and go to state 147
    DISTANCE        shift and go to state 148
    STOP            shift and go to state 149
    WHILE           shift and go to state 150
    RETURN          shift and go to state 151

    block                          shift and go to state 118
    statute                        shift and go to state 119
    empty                          shift and go to state 120
    cond                           shift and go to state 121
    assign                         shift and go to state 122
    call                           shift and go to state 123
    cin                            shift and go to state 124
    cout                           shift and go to state 125
    delay                          shift and go to state 126
    forward                        shift and go to state 127
    backward                       shift and go to state 128
    turnleft                       shift and go to state 129
    turnright                      shift and go to state 130
    servo                          shift and go to state 131
    lights                         shift and go to state 132
    distance                       shift and go to state 133
    stop                           shift and go to state 134
    while                          shift and go to state 135
    return                         shift and go to state 136
    era                            shift and go to state 51

state 109

    (4) main1 -> empty .

    IF              reduce using rule 4 (main1 -> empty .)
    ID              reduce using rule 4 (main1 -> empty .)
    CIN             reduce using rule 4 (main1 -> empty .)
    COUT            reduce using rule 4 (main1 -> empty .)
    DELAY           reduce using rule 4 (main1 -> empty .)
    FORWARD         reduce using rule 4 (main1 -> empty .)
    BACKWARD        reduce using rule 4 (main1 -> empty .)
    TURNLEFT        reduce using rule 4 (main1 -> empty .)
    TURNRIGHT       reduce using rule 4 (main1 -> empty .)
    SERVO           reduce using rule 4 (main1 -> empty .)
    LIGHTS          reduce using rule 4 (main1 -> empty .)
    DISTANCE        reduce using rule 4 (main1 -> empty .)
    STOP            reduce using rule 4 (main1 -> empty .)
    WHILE           reduce using rule 4 (main1 -> empty .)
    RETURN          reduce using rule 4 (main1 -> empty .)
    RCURLY          reduce using rule 4 (main1 -> empty .)


state 110

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock . funcs1 block RCURLY
    (9) funcs1 -> . empty
    (113) empty -> .

    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    funcs1                         shift and go to state 152
    empty                          shift and go to state 153

state 111

    (108) factor -> LPAREN insertfloor express RPAREN endfloor .

    MULTI           reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    DIVI            reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    PLUS            reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    MINUS           reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    LESSTHAN        reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    GREATERTHAN     reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    EQUALS          reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    NOTEQUALS       reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    AND             reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    OR              reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    RBRACKET        reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    RPAREN          reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    COMMA           reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)
    SEMICOLON       reduce using rule 108 (factor -> LPAREN insertfloor express RPAREN endfloor .)


state 112

    (112) endfloor -> empty .

    MULTI           reduce using rule 112 (endfloor -> empty .)
    DIVI            reduce using rule 112 (endfloor -> empty .)
    PLUS            reduce using rule 112 (endfloor -> empty .)
    MINUS           reduce using rule 112 (endfloor -> empty .)
    LESSTHAN        reduce using rule 112 (endfloor -> empty .)
    GREATERTHAN     reduce using rule 112 (endfloor -> empty .)
    EQUALS          reduce using rule 112 (endfloor -> empty .)
    NOTEQUALS       reduce using rule 112 (endfloor -> empty .)
    AND             reduce using rule 112 (endfloor -> empty .)
    OR              reduce using rule 112 (endfloor -> empty .)
    RBRACKET        reduce using rule 112 (endfloor -> empty .)
    RPAREN          reduce using rule 112 (endfloor -> empty .)
    COMMA           reduce using rule 112 (endfloor -> empty .)
    SEMICOLON       reduce using rule 112 (endfloor -> empty .)
    ASSIGN          reduce using rule 112 (endfloor -> empty .)


state 113

    (83) array -> LBRACKET insertfloor express RBRACKET . endfloor
    (112) endfloor -> . empty
    (113) empty -> .

    MULTI           reduce using rule 113 (empty -> .)
    DIVI            reduce using rule 113 (empty -> .)
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    GREATERTHAN     reduce using rule 113 (empty -> .)
    EQUALS          reduce using rule 113 (empty -> .)
    NOTEQUALS       reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    ASSIGN          reduce using rule 113 (empty -> .)

    endfloor                       shift and go to state 154
    empty                          shift and go to state 112

state 114

    (45) call -> era LPAREN insertfloor paramcall RPAREN . endfloor
    (112) endfloor -> . empty
    (113) empty -> .

    MULTI           reduce using rule 113 (empty -> .)
    DIVI            reduce using rule 113 (empty -> .)
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    GREATERTHAN     reduce using rule 113 (empty -> .)
    EQUALS          reduce using rule 113 (empty -> .)
    NOTEQUALS       reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    RBRACKET        reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    endfloor                       shift and go to state 155
    empty                          shift and go to state 112

state 115

    (47) paramcall -> express paramcall1 .

    RPAREN          reduce using rule 47 (paramcall -> express paramcall1 .)


state 116

    (49) paramcall1 -> COMMA . paramcall
    (47) paramcall -> . express paramcall1
    (48) paramcall -> . empty
    (85) express -> . relational express1
    (113) empty -> .
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    RPAREN          reduce using rule 113 (empty -> .)
    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    paramcall                      shift and go to state 156
    express                        shift and go to state 106
    empty                          shift and go to state 107
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 117

    (50) paramcall1 -> empty .

    RPAREN          reduce using rule 50 (paramcall1 -> empty .)


state 118

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block . RCURLY

    RCURLY          shift and go to state 157


state 119

    (21) block -> statute . SEMICOLON block

    SEMICOLON       shift and go to state 158


state 120

    (22) block -> empty .

    RCURLY          reduce using rule 22 (block -> empty .)


state 121

    (23) statute -> cond .

    SEMICOLON       reduce using rule 23 (statute -> cond .)


state 122

    (24) statute -> assign .

    SEMICOLON       reduce using rule 24 (statute -> assign .)


state 123

    (25) statute -> call .

    SEMICOLON       reduce using rule 25 (statute -> call .)


state 124

    (26) statute -> cin .

    SEMICOLON       reduce using rule 26 (statute -> cin .)


state 125

    (27) statute -> cout .

    SEMICOLON       reduce using rule 27 (statute -> cout .)


state 126

    (28) statute -> delay .

    SEMICOLON       reduce using rule 28 (statute -> delay .)


state 127

    (29) statute -> forward .

    SEMICOLON       reduce using rule 29 (statute -> forward .)


state 128

    (30) statute -> backward .

    SEMICOLON       reduce using rule 30 (statute -> backward .)


state 129

    (31) statute -> turnleft .

    SEMICOLON       reduce using rule 31 (statute -> turnleft .)


state 130

    (32) statute -> turnright .

    SEMICOLON       reduce using rule 32 (statute -> turnright .)


state 131

    (33) statute -> servo .

    SEMICOLON       reduce using rule 33 (statute -> servo .)


state 132

    (34) statute -> lights .

    SEMICOLON       reduce using rule 34 (statute -> lights .)


state 133

    (35) statute -> distance .

    SEMICOLON       reduce using rule 35 (statute -> distance .)


state 134

    (36) statute -> stop .

    SEMICOLON       reduce using rule 36 (statute -> stop .)


state 135

    (37) statute -> while .

    SEMICOLON       reduce using rule 37 (statute -> while .)


state 136

    (38) statute -> return .

    SEMICOLON       reduce using rule 38 (statute -> return .)


state 137

    (39) cond -> IF . LPAREN express RPAREN LCURLY gotoif block RCURLY else

    LPAREN          shift and go to state 159


state 138

    (44) assign -> ID . array ASSIGN express
    (46) era -> ID .
    (83) array -> . LBRACKET insertfloor express RBRACKET endfloor
    (84) array -> . empty
    (113) empty -> .

    LPAREN          reduce using rule 46 (era -> ID .)
    LBRACKET        shift and go to state 84
    ASSIGN          reduce using rule 113 (empty -> .)

    array                          shift and go to state 160
    empty                          shift and go to state 85

state 139

    (51) cin -> CIN . cin1
    (52) cin1 -> . cin2
    (53) cin1 -> . cin3
    (54) cin2 -> . LPAREN ID RPAREN
    (55) cin3 -> . LBRACKET CTE_INT RBRACKET LPAREN cin4 RPAREN

    LPAREN          shift and go to state 164
    LBRACKET        shift and go to state 165

    cin1                           shift and go to state 161
    cin2                           shift and go to state 162
    cin3                           shift and go to state 163

state 140

    (58) cout -> COUT . LPAREN express cout1 RPAREN

    LPAREN          shift and go to state 166


state 141

    (61) delay -> DELAY . LPAREN express RPAREN

    LPAREN          shift and go to state 167


state 142

    (62) forward -> FORWARD . LPAREN express RPAREN

    LPAREN          shift and go to state 168


state 143

    (63) backward -> BACKWARD . LPAREN express RPAREN

    LPAREN          shift and go to state 169


state 144

    (64) turnleft -> TURNLEFT . LPAREN express RPAREN

    LPAREN          shift and go to state 170


state 145

    (65) turnright -> TURNRIGHT . LPAREN express RPAREN

    LPAREN          shift and go to state 171


state 146

    (66) servo -> SERVO . LPAREN express RPAREN

    LPAREN          shift and go to state 172


state 147

    (67) lights -> LIGHTS . LPAREN express COMMA express RPAREN

    LPAREN          shift and go to state 173


state 148

    (68) distance -> DISTANCE . LPAREN RPAREN

    LPAREN          shift and go to state 174


state 149

    (69) stop -> STOP . LPAREN RPAREN

    LPAREN          shift and go to state 175


state 150

    (70) while -> WHILE . LPAREN express RPAREN while1 LCURLY block RCURLY

    LPAREN          shift and go to state 176


state 151

    (72) return -> RETURN . LPAREN express RPAREN

    LPAREN          shift and go to state 177


state 152

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 . block RCURLY
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID array ASSIGN express
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (51) cin -> . CIN cin1
    (58) cout -> . COUT LPAREN express cout1 RPAREN
    (61) delay -> . DELAY LPAREN express RPAREN
    (62) forward -> . FORWARD LPAREN express RPAREN
    (63) backward -> . BACKWARD LPAREN express RPAREN
    (64) turnleft -> . TURNLEFT LPAREN express RPAREN
    (65) turnright -> . TURNRIGHT LPAREN express RPAREN
    (66) servo -> . SERVO LPAREN express RPAREN
    (67) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (68) distance -> . DISTANCE LPAREN RPAREN
    (69) stop -> . STOP LPAREN RPAREN
    (70) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (72) return -> . RETURN LPAREN express RPAREN
    (46) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 137
    ID              shift and go to state 138
    CIN             shift and go to state 139
    COUT            shift and go to state 140
    DELAY           shift and go to state 141
    FORWARD         shift and go to state 142
    BACKWARD        shift and go to state 143
    TURNLEFT        shift and go to state 144
    TURNRIGHT       shift and go to state 145
    SERVO           shift and go to state 146
    LIGHTS          shift and go to state 147
    DISTANCE        shift and go to state 148
    STOP            shift and go to state 149
    WHILE           shift and go to state 150
    RETURN          shift and go to state 151

    block                          shift and go to state 178
    statute                        shift and go to state 119
    empty                          shift and go to state 120
    cond                           shift and go to state 121
    assign                         shift and go to state 122
    call                           shift and go to state 123
    cin                            shift and go to state 124
    cout                           shift and go to state 125
    delay                          shift and go to state 126
    forward                        shift and go to state 127
    backward                       shift and go to state 128
    turnleft                       shift and go to state 129
    turnright                      shift and go to state 130
    servo                          shift and go to state 131
    lights                         shift and go to state 132
    distance                       shift and go to state 133
    stop                           shift and go to state 134
    while                          shift and go to state 135
    return                         shift and go to state 136
    era                            shift and go to state 51

state 153

    (9) funcs1 -> empty .

    IF              reduce using rule 9 (funcs1 -> empty .)
    ID              reduce using rule 9 (funcs1 -> empty .)
    CIN             reduce using rule 9 (funcs1 -> empty .)
    COUT            reduce using rule 9 (funcs1 -> empty .)
    DELAY           reduce using rule 9 (funcs1 -> empty .)
    FORWARD         reduce using rule 9 (funcs1 -> empty .)
    BACKWARD        reduce using rule 9 (funcs1 -> empty .)
    TURNLEFT        reduce using rule 9 (funcs1 -> empty .)
    TURNRIGHT       reduce using rule 9 (funcs1 -> empty .)
    SERVO           reduce using rule 9 (funcs1 -> empty .)
    LIGHTS          reduce using rule 9 (funcs1 -> empty .)
    DISTANCE        reduce using rule 9 (funcs1 -> empty .)
    STOP            reduce using rule 9 (funcs1 -> empty .)
    WHILE           reduce using rule 9 (funcs1 -> empty .)
    RETURN          reduce using rule 9 (funcs1 -> empty .)
    RCURLY          reduce using rule 9 (funcs1 -> empty .)


state 154

    (83) array -> LBRACKET insertfloor express RBRACKET endfloor .

    MULTI           reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    DIVI            reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    PLUS            reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    MINUS           reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    LESSTHAN        reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    GREATERTHAN     reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    EQUALS          reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    NOTEQUALS       reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    AND             reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    OR              reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    RBRACKET        reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    RPAREN          reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    COMMA           reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    SEMICOLON       reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)
    ASSIGN          reduce using rule 83 (array -> LBRACKET insertfloor express RBRACKET endfloor .)


state 155

    (45) call -> era LPAREN insertfloor paramcall RPAREN endfloor .

    MULTI           reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    DIVI            reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    PLUS            reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    MINUS           reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    LESSTHAN        reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    GREATERTHAN     reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    EQUALS          reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    NOTEQUALS       reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    AND             reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    OR              reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    RBRACKET        reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    RPAREN          reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    COMMA           reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)
    SEMICOLON       reduce using rule 45 (call -> era LPAREN insertfloor paramcall RPAREN endfloor .)


state 156

    (49) paramcall1 -> COMMA paramcall .

    RPAREN          reduce using rule 49 (paramcall1 -> COMMA paramcall .)


state 157

    (3) main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY .

    FIN             reduce using rule 3 (main -> MAIN setmain LPAREN RPAREN LCURLY varsblock main1 block RCURLY .)


state 158

    (21) block -> statute SEMICOLON . block
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID array ASSIGN express
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (51) cin -> . CIN cin1
    (58) cout -> . COUT LPAREN express cout1 RPAREN
    (61) delay -> . DELAY LPAREN express RPAREN
    (62) forward -> . FORWARD LPAREN express RPAREN
    (63) backward -> . BACKWARD LPAREN express RPAREN
    (64) turnleft -> . TURNLEFT LPAREN express RPAREN
    (65) turnright -> . TURNRIGHT LPAREN express RPAREN
    (66) servo -> . SERVO LPAREN express RPAREN
    (67) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (68) distance -> . DISTANCE LPAREN RPAREN
    (69) stop -> . STOP LPAREN RPAREN
    (70) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (72) return -> . RETURN LPAREN express RPAREN
    (46) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 137
    ID              shift and go to state 138
    CIN             shift and go to state 139
    COUT            shift and go to state 140
    DELAY           shift and go to state 141
    FORWARD         shift and go to state 142
    BACKWARD        shift and go to state 143
    TURNLEFT        shift and go to state 144
    TURNRIGHT       shift and go to state 145
    SERVO           shift and go to state 146
    LIGHTS          shift and go to state 147
    DISTANCE        shift and go to state 148
    STOP            shift and go to state 149
    WHILE           shift and go to state 150
    RETURN          shift and go to state 151

    statute                        shift and go to state 119
    block                          shift and go to state 179
    empty                          shift and go to state 120
    cond                           shift and go to state 121
    assign                         shift and go to state 122
    call                           shift and go to state 123
    cin                            shift and go to state 124
    cout                           shift and go to state 125
    delay                          shift and go to state 126
    forward                        shift and go to state 127
    backward                       shift and go to state 128
    turnleft                       shift and go to state 129
    turnright                      shift and go to state 130
    servo                          shift and go to state 131
    lights                         shift and go to state 132
    distance                       shift and go to state 133
    stop                           shift and go to state 134
    while                          shift and go to state 135
    return                         shift and go to state 136
    era                            shift and go to state 51

state 159

    (39) cond -> IF LPAREN . express RPAREN LCURLY gotoif block RCURLY else
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 180
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 160

    (44) assign -> ID array . ASSIGN express

    ASSIGN          shift and go to state 181


state 161

    (51) cin -> CIN cin1 .

    SEMICOLON       reduce using rule 51 (cin -> CIN cin1 .)


state 162

    (52) cin1 -> cin2 .

    SEMICOLON       reduce using rule 52 (cin1 -> cin2 .)


state 163

    (53) cin1 -> cin3 .

    SEMICOLON       reduce using rule 53 (cin1 -> cin3 .)


state 164

    (54) cin2 -> LPAREN . ID RPAREN

    ID              shift and go to state 182


state 165

    (55) cin3 -> LBRACKET . CTE_INT RBRACKET LPAREN cin4 RPAREN

    CTE_INT         shift and go to state 183


state 166

    (58) cout -> COUT LPAREN . express cout1 RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 184
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 167

    (61) delay -> DELAY LPAREN . express RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 185
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 168

    (62) forward -> FORWARD LPAREN . express RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 186
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 169

    (63) backward -> BACKWARD LPAREN . express RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 187
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 170

    (64) turnleft -> TURNLEFT LPAREN . express RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 188
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 171

    (65) turnright -> TURNRIGHT LPAREN . express RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 189
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 172

    (66) servo -> SERVO LPAREN . express RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 190
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 173

    (67) lights -> LIGHTS LPAREN . express COMMA express RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 191
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 174

    (68) distance -> DISTANCE LPAREN . RPAREN

    RPAREN          shift and go to state 192


state 175

    (69) stop -> STOP LPAREN . RPAREN

    RPAREN          shift and go to state 193


state 176

    (70) while -> WHILE LPAREN . express RPAREN while1 LCURLY block RCURLY
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 194
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 177

    (72) return -> RETURN LPAREN . express RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 195
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 178

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block . RCURLY

    RCURLY          shift and go to state 196


state 179

    (21) block -> statute SEMICOLON block .

    RCURLY          reduce using rule 21 (block -> statute SEMICOLON block .)


state 180

    (39) cond -> IF LPAREN express . RPAREN LCURLY gotoif block RCURLY else

    RPAREN          shift and go to state 197


state 181

    (44) assign -> ID array ASSIGN . express
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 198
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 182

    (54) cin2 -> LPAREN ID . RPAREN

    RPAREN          shift and go to state 199


state 183

    (55) cin3 -> LBRACKET CTE_INT . RBRACKET LPAREN cin4 RPAREN

    RBRACKET        shift and go to state 200


state 184

    (58) cout -> COUT LPAREN express . cout1 RPAREN
    (59) cout1 -> . COMMA express cout1
    (60) cout1 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 202
    RPAREN          reduce using rule 113 (empty -> .)

    cout1                          shift and go to state 201
    empty                          shift and go to state 203

state 185

    (61) delay -> DELAY LPAREN express . RPAREN

    RPAREN          shift and go to state 204


state 186

    (62) forward -> FORWARD LPAREN express . RPAREN

    RPAREN          shift and go to state 205


state 187

    (63) backward -> BACKWARD LPAREN express . RPAREN

    RPAREN          shift and go to state 206


state 188

    (64) turnleft -> TURNLEFT LPAREN express . RPAREN

    RPAREN          shift and go to state 207


state 189

    (65) turnright -> TURNRIGHT LPAREN express . RPAREN

    RPAREN          shift and go to state 208


state 190

    (66) servo -> SERVO LPAREN express . RPAREN

    RPAREN          shift and go to state 209


state 191

    (67) lights -> LIGHTS LPAREN express . COMMA express RPAREN

    COMMA           shift and go to state 210


state 192

    (68) distance -> DISTANCE LPAREN RPAREN .

    SEMICOLON       reduce using rule 68 (distance -> DISTANCE LPAREN RPAREN .)


state 193

    (69) stop -> STOP LPAREN RPAREN .

    SEMICOLON       reduce using rule 69 (stop -> STOP LPAREN RPAREN .)


state 194

    (70) while -> WHILE LPAREN express . RPAREN while1 LCURLY block RCURLY

    RPAREN          shift and go to state 211


state 195

    (72) return -> RETURN LPAREN express . RPAREN

    RPAREN          shift and go to state 212


state 196

    (8) funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY .

    FUNCDEF         reduce using rule 8 (funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY .)
    MAIN            reduce using rule 8 (funcs -> FUNCDEF type setscope LPAREN paramsblock RPAREN LCURLY varsblock funcs1 block RCURLY .)


state 197

    (39) cond -> IF LPAREN express RPAREN . LCURLY gotoif block RCURLY else

    LCURLY          shift and go to state 213


state 198

    (44) assign -> ID array ASSIGN express .

    SEMICOLON       reduce using rule 44 (assign -> ID array ASSIGN express .)


state 199

    (54) cin2 -> LPAREN ID RPAREN .

    SEMICOLON       reduce using rule 54 (cin2 -> LPAREN ID RPAREN .)


state 200

    (55) cin3 -> LBRACKET CTE_INT RBRACKET . LPAREN cin4 RPAREN

    LPAREN          shift and go to state 214


state 201

    (58) cout -> COUT LPAREN express cout1 . RPAREN

    RPAREN          shift and go to state 215


state 202

    (59) cout1 -> COMMA . express cout1
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 216
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 203

    (60) cout1 -> empty .

    RPAREN          reduce using rule 60 (cout1 -> empty .)


state 204

    (61) delay -> DELAY LPAREN express RPAREN .

    SEMICOLON       reduce using rule 61 (delay -> DELAY LPAREN express RPAREN .)


state 205

    (62) forward -> FORWARD LPAREN express RPAREN .

    SEMICOLON       reduce using rule 62 (forward -> FORWARD LPAREN express RPAREN .)


state 206

    (63) backward -> BACKWARD LPAREN express RPAREN .

    SEMICOLON       reduce using rule 63 (backward -> BACKWARD LPAREN express RPAREN .)


state 207

    (64) turnleft -> TURNLEFT LPAREN express RPAREN .

    SEMICOLON       reduce using rule 64 (turnleft -> TURNLEFT LPAREN express RPAREN .)


state 208

    (65) turnright -> TURNRIGHT LPAREN express RPAREN .

    SEMICOLON       reduce using rule 65 (turnright -> TURNRIGHT LPAREN express RPAREN .)


state 209

    (66) servo -> SERVO LPAREN express RPAREN .

    SEMICOLON       reduce using rule 66 (servo -> SERVO LPAREN express RPAREN .)


state 210

    (67) lights -> LIGHTS LPAREN express COMMA . express RPAREN
    (85) express -> . relational express1
    (90) relational -> . exp relational1
    (91) relational -> . NOT
    (98) exp -> . term exp1
    (103) term -> . factor term1
    (108) factor -> . LPAREN insertfloor express RPAREN endfloor
    (109) factor -> . constant
    (110) factor -> . call
    (78) constant -> . ID array
    (79) constant -> . CTE_INT
    (80) constant -> . CTE_FLOAT
    (81) constant -> . CTE_CHAR
    (82) constant -> . CTE_BOOL
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (46) era -> . ID

    NOT             shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 46
    CTE_INT         shift and go to state 47
    CTE_FLOAT       shift and go to state 48
    CTE_CHAR        shift and go to state 49
    CTE_BOOL        shift and go to state 50

    express                        shift and go to state 217
    relational                     shift and go to state 38
    exp                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 42
    constant                       shift and go to state 44
    call                           shift and go to state 45
    era                            shift and go to state 51

state 211

    (70) while -> WHILE LPAREN express RPAREN . while1 LCURLY block RCURLY
    (71) while1 -> . empty
    (113) empty -> .

    LCURLY          reduce using rule 113 (empty -> .)

    while1                         shift and go to state 218
    empty                          shift and go to state 219

state 212

    (72) return -> RETURN LPAREN express RPAREN .

    SEMICOLON       reduce using rule 72 (return -> RETURN LPAREN express RPAREN .)


state 213

    (39) cond -> IF LPAREN express RPAREN LCURLY . gotoif block RCURLY else
    (40) gotoif -> . empty
    (113) empty -> .

    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    gotoif                         shift and go to state 220
    empty                          shift and go to state 221

state 214

    (55) cin3 -> LBRACKET CTE_INT RBRACKET LPAREN . cin4 RPAREN
    (56) cin4 -> . COMMA ID cin4
    (57) cin4 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 223
    RPAREN          reduce using rule 113 (empty -> .)

    cin4                           shift and go to state 222
    empty                          shift and go to state 224

state 215

    (58) cout -> COUT LPAREN express cout1 RPAREN .

    SEMICOLON       reduce using rule 58 (cout -> COUT LPAREN express cout1 RPAREN .)


state 216

    (59) cout1 -> COMMA express . cout1
    (59) cout1 -> . COMMA express cout1
    (60) cout1 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 202
    RPAREN          reduce using rule 113 (empty -> .)

    cout1                          shift and go to state 225
    empty                          shift and go to state 203

state 217

    (67) lights -> LIGHTS LPAREN express COMMA express . RPAREN

    RPAREN          shift and go to state 226


state 218

    (70) while -> WHILE LPAREN express RPAREN while1 . LCURLY block RCURLY

    LCURLY          shift and go to state 227


state 219

    (71) while1 -> empty .

    LCURLY          reduce using rule 71 (while1 -> empty .)


state 220

    (39) cond -> IF LPAREN express RPAREN LCURLY gotoif . block RCURLY else
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID array ASSIGN express
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (51) cin -> . CIN cin1
    (58) cout -> . COUT LPAREN express cout1 RPAREN
    (61) delay -> . DELAY LPAREN express RPAREN
    (62) forward -> . FORWARD LPAREN express RPAREN
    (63) backward -> . BACKWARD LPAREN express RPAREN
    (64) turnleft -> . TURNLEFT LPAREN express RPAREN
    (65) turnright -> . TURNRIGHT LPAREN express RPAREN
    (66) servo -> . SERVO LPAREN express RPAREN
    (67) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (68) distance -> . DISTANCE LPAREN RPAREN
    (69) stop -> . STOP LPAREN RPAREN
    (70) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (72) return -> . RETURN LPAREN express RPAREN
    (46) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 137
    ID              shift and go to state 138
    CIN             shift and go to state 139
    COUT            shift and go to state 140
    DELAY           shift and go to state 141
    FORWARD         shift and go to state 142
    BACKWARD        shift and go to state 143
    TURNLEFT        shift and go to state 144
    TURNRIGHT       shift and go to state 145
    SERVO           shift and go to state 146
    LIGHTS          shift and go to state 147
    DISTANCE        shift and go to state 148
    STOP            shift and go to state 149
    WHILE           shift and go to state 150
    RETURN          shift and go to state 151

    block                          shift and go to state 228
    statute                        shift and go to state 119
    empty                          shift and go to state 120
    cond                           shift and go to state 121
    assign                         shift and go to state 122
    call                           shift and go to state 123
    cin                            shift and go to state 124
    cout                           shift and go to state 125
    delay                          shift and go to state 126
    forward                        shift and go to state 127
    backward                       shift and go to state 128
    turnleft                       shift and go to state 129
    turnright                      shift and go to state 130
    servo                          shift and go to state 131
    lights                         shift and go to state 132
    distance                       shift and go to state 133
    stop                           shift and go to state 134
    while                          shift and go to state 135
    return                         shift and go to state 136
    era                            shift and go to state 51

state 221

    (40) gotoif -> empty .

    IF              reduce using rule 40 (gotoif -> empty .)
    ID              reduce using rule 40 (gotoif -> empty .)
    CIN             reduce using rule 40 (gotoif -> empty .)
    COUT            reduce using rule 40 (gotoif -> empty .)
    DELAY           reduce using rule 40 (gotoif -> empty .)
    FORWARD         reduce using rule 40 (gotoif -> empty .)
    BACKWARD        reduce using rule 40 (gotoif -> empty .)
    TURNLEFT        reduce using rule 40 (gotoif -> empty .)
    TURNRIGHT       reduce using rule 40 (gotoif -> empty .)
    SERVO           reduce using rule 40 (gotoif -> empty .)
    LIGHTS          reduce using rule 40 (gotoif -> empty .)
    DISTANCE        reduce using rule 40 (gotoif -> empty .)
    STOP            reduce using rule 40 (gotoif -> empty .)
    WHILE           reduce using rule 40 (gotoif -> empty .)
    RETURN          reduce using rule 40 (gotoif -> empty .)
    RCURLY          reduce using rule 40 (gotoif -> empty .)


state 222

    (55) cin3 -> LBRACKET CTE_INT RBRACKET LPAREN cin4 . RPAREN

    RPAREN          shift and go to state 229


state 223

    (56) cin4 -> COMMA . ID cin4

    ID              shift and go to state 230


state 224

    (57) cin4 -> empty .

    RPAREN          reduce using rule 57 (cin4 -> empty .)


state 225

    (59) cout1 -> COMMA express cout1 .

    RPAREN          reduce using rule 59 (cout1 -> COMMA express cout1 .)


state 226

    (67) lights -> LIGHTS LPAREN express COMMA express RPAREN .

    SEMICOLON       reduce using rule 67 (lights -> LIGHTS LPAREN express COMMA express RPAREN .)


state 227

    (70) while -> WHILE LPAREN express RPAREN while1 LCURLY . block RCURLY
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID array ASSIGN express
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (51) cin -> . CIN cin1
    (58) cout -> . COUT LPAREN express cout1 RPAREN
    (61) delay -> . DELAY LPAREN express RPAREN
    (62) forward -> . FORWARD LPAREN express RPAREN
    (63) backward -> . BACKWARD LPAREN express RPAREN
    (64) turnleft -> . TURNLEFT LPAREN express RPAREN
    (65) turnright -> . TURNRIGHT LPAREN express RPAREN
    (66) servo -> . SERVO LPAREN express RPAREN
    (67) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (68) distance -> . DISTANCE LPAREN RPAREN
    (69) stop -> . STOP LPAREN RPAREN
    (70) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (72) return -> . RETURN LPAREN express RPAREN
    (46) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 137
    ID              shift and go to state 138
    CIN             shift and go to state 139
    COUT            shift and go to state 140
    DELAY           shift and go to state 141
    FORWARD         shift and go to state 142
    BACKWARD        shift and go to state 143
    TURNLEFT        shift and go to state 144
    TURNRIGHT       shift and go to state 145
    SERVO           shift and go to state 146
    LIGHTS          shift and go to state 147
    DISTANCE        shift and go to state 148
    STOP            shift and go to state 149
    WHILE           shift and go to state 150
    RETURN          shift and go to state 151

    block                          shift and go to state 231
    statute                        shift and go to state 119
    empty                          shift and go to state 120
    cond                           shift and go to state 121
    assign                         shift and go to state 122
    call                           shift and go to state 123
    cin                            shift and go to state 124
    cout                           shift and go to state 125
    delay                          shift and go to state 126
    forward                        shift and go to state 127
    backward                       shift and go to state 128
    turnleft                       shift and go to state 129
    turnright                      shift and go to state 130
    servo                          shift and go to state 131
    lights                         shift and go to state 132
    distance                       shift and go to state 133
    stop                           shift and go to state 134
    while                          shift and go to state 135
    return                         shift and go to state 136
    era                            shift and go to state 51

state 228

    (39) cond -> IF LPAREN express RPAREN LCURLY gotoif block . RCURLY else

    RCURLY          shift and go to state 232


state 229

    (55) cin3 -> LBRACKET CTE_INT RBRACKET LPAREN cin4 RPAREN .

    SEMICOLON       reduce using rule 55 (cin3 -> LBRACKET CTE_INT RBRACKET LPAREN cin4 RPAREN .)


state 230

    (56) cin4 -> COMMA ID . cin4
    (56) cin4 -> . COMMA ID cin4
    (57) cin4 -> . empty
    (113) empty -> .

    COMMA           shift and go to state 223
    RPAREN          reduce using rule 113 (empty -> .)

    cin4                           shift and go to state 233
    empty                          shift and go to state 224

state 231

    (70) while -> WHILE LPAREN express RPAREN while1 LCURLY block . RCURLY

    RCURLY          shift and go to state 234


state 232

    (39) cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY . else
    (41) else -> . ELSE LCURLY gotoelse block RCURLY else
    (42) else -> . empty
    (113) empty -> .

    ELSE            shift and go to state 236
    SEMICOLON       reduce using rule 113 (empty -> .)

    else                           shift and go to state 235
    empty                          shift and go to state 237

state 233

    (56) cin4 -> COMMA ID cin4 .

    RPAREN          reduce using rule 56 (cin4 -> COMMA ID cin4 .)


state 234

    (70) while -> WHILE LPAREN express RPAREN while1 LCURLY block RCURLY .

    SEMICOLON       reduce using rule 70 (while -> WHILE LPAREN express RPAREN while1 LCURLY block RCURLY .)


state 235

    (39) cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY else .

    SEMICOLON       reduce using rule 39 (cond -> IF LPAREN express RPAREN LCURLY gotoif block RCURLY else .)


state 236

    (41) else -> ELSE . LCURLY gotoelse block RCURLY else

    LCURLY          shift and go to state 238


state 237

    (42) else -> empty .

    SEMICOLON       reduce using rule 42 (else -> empty .)


state 238

    (41) else -> ELSE LCURLY . gotoelse block RCURLY else
    (43) gotoelse -> . empty
    (113) empty -> .

    IF              reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CIN             reduce using rule 113 (empty -> .)
    COUT            reduce using rule 113 (empty -> .)
    DELAY           reduce using rule 113 (empty -> .)
    FORWARD         reduce using rule 113 (empty -> .)
    BACKWARD        reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    SERVO           reduce using rule 113 (empty -> .)
    LIGHTS          reduce using rule 113 (empty -> .)
    DISTANCE        reduce using rule 113 (empty -> .)
    STOP            reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCURLY          reduce using rule 113 (empty -> .)

    gotoelse                       shift and go to state 239
    empty                          shift and go to state 240

state 239

    (41) else -> ELSE LCURLY gotoelse . block RCURLY else
    (21) block -> . statute SEMICOLON block
    (22) block -> . empty
    (23) statute -> . cond
    (24) statute -> . assign
    (25) statute -> . call
    (26) statute -> . cin
    (27) statute -> . cout
    (28) statute -> . delay
    (29) statute -> . forward
    (30) statute -> . backward
    (31) statute -> . turnleft
    (32) statute -> . turnright
    (33) statute -> . servo
    (34) statute -> . lights
    (35) statute -> . distance
    (36) statute -> . stop
    (37) statute -> . while
    (38) statute -> . return
    (113) empty -> .
    (39) cond -> . IF LPAREN express RPAREN LCURLY gotoif block RCURLY else
    (44) assign -> . ID array ASSIGN express
    (45) call -> . era LPAREN insertfloor paramcall RPAREN endfloor
    (51) cin -> . CIN cin1
    (58) cout -> . COUT LPAREN express cout1 RPAREN
    (61) delay -> . DELAY LPAREN express RPAREN
    (62) forward -> . FORWARD LPAREN express RPAREN
    (63) backward -> . BACKWARD LPAREN express RPAREN
    (64) turnleft -> . TURNLEFT LPAREN express RPAREN
    (65) turnright -> . TURNRIGHT LPAREN express RPAREN
    (66) servo -> . SERVO LPAREN express RPAREN
    (67) lights -> . LIGHTS LPAREN express COMMA express RPAREN
    (68) distance -> . DISTANCE LPAREN RPAREN
    (69) stop -> . STOP LPAREN RPAREN
    (70) while -> . WHILE LPAREN express RPAREN while1 LCURLY block RCURLY
    (72) return -> . RETURN LPAREN express RPAREN
    (46) era -> . ID

    RCURLY          reduce using rule 113 (empty -> .)
    IF              shift and go to state 137
    ID              shift and go to state 138
    CIN             shift and go to state 139
    COUT            shift and go to state 140
    DELAY           shift and go to state 141
    FORWARD         shift and go to state 142
    BACKWARD        shift and go to state 143
    TURNLEFT        shift and go to state 144
    TURNRIGHT       shift and go to state 145
    SERVO           shift and go to state 146
    LIGHTS          shift and go to state 147
    DISTANCE        shift and go to state 148
    STOP            shift and go to state 149
    WHILE           shift and go to state 150
    RETURN          shift and go to state 151

    block                          shift and go to state 241
    statute                        shift and go to state 119
    empty                          shift and go to state 120
    cond                           shift and go to state 121
    assign                         shift and go to state 122
    call                           shift and go to state 123
    cin                            shift and go to state 124
    cout                           shift and go to state 125
    delay                          shift and go to state 126
    forward                        shift and go to state 127
    backward                       shift and go to state 128
    turnleft                       shift and go to state 129
    turnright                      shift and go to state 130
    servo                          shift and go to state 131
    lights                         shift and go to state 132
    distance                       shift and go to state 133
    stop                           shift and go to state 134
    while                          shift and go to state 135
    return                         shift and go to state 136
    era                            shift and go to state 51

state 240

    (43) gotoelse -> empty .

    IF              reduce using rule 43 (gotoelse -> empty .)
    ID              reduce using rule 43 (gotoelse -> empty .)
    CIN             reduce using rule 43 (gotoelse -> empty .)
    COUT            reduce using rule 43 (gotoelse -> empty .)
    DELAY           reduce using rule 43 (gotoelse -> empty .)
    FORWARD         reduce using rule 43 (gotoelse -> empty .)
    BACKWARD        reduce using rule 43 (gotoelse -> empty .)
    TURNLEFT        reduce using rule 43 (gotoelse -> empty .)
    TURNRIGHT       reduce using rule 43 (gotoelse -> empty .)
    SERVO           reduce using rule 43 (gotoelse -> empty .)
    LIGHTS          reduce using rule 43 (gotoelse -> empty .)
    DISTANCE        reduce using rule 43 (gotoelse -> empty .)
    STOP            reduce using rule 43 (gotoelse -> empty .)
    WHILE           reduce using rule 43 (gotoelse -> empty .)
    RETURN          reduce using rule 43 (gotoelse -> empty .)
    RCURLY          reduce using rule 43 (gotoelse -> empty .)


state 241

    (41) else -> ELSE LCURLY gotoelse block . RCURLY else

    RCURLY          shift and go to state 242


state 242

    (41) else -> ELSE LCURLY gotoelse block RCURLY . else
    (41) else -> . ELSE LCURLY gotoelse block RCURLY else
    (42) else -> . empty
    (113) empty -> .

    ELSE            shift and go to state 236
    SEMICOLON       reduce using rule 113 (empty -> .)

    else                           shift and go to state 243
    empty                          shift and go to state 237

state 243

    (41) else -> ELSE LCURLY gotoelse block RCURLY else .

    SEMICOLON       reduce using rule 41 (else -> ELSE LCURLY gotoelse block RCURLY else .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 35 resolved as shift
WARNING: shift/reduce conflict for INT in state 35 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 35 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 35 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 35 resolved as shift
WARNING: shift/reduce conflict for VOID in state 35 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 55 resolved as shift
WARNING: shift/reduce conflict for INT in state 55 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 55 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 55 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 55 resolved as shift
WARNING: shift/reduce conflict for VOID in state 55 resolved as shift
WARNING: shift/reduce conflict for INT in state 56 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 56 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 56 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 56 resolved as shift
WARNING: shift/reduce conflict for VOID in state 56 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 91 resolved as shift
WARNING: shift/reduce conflict for INT in state 91 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 91 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 91 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 91 resolved as shift
WARNING: shift/reduce conflict for VOID in state 91 resolved as shift
WARNING: reduce/reduce conflict in state 57 resolved using rule (paramsblock -> empty)
WARNING: rejected rule (params -> empty) in state 57
